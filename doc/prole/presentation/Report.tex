\documentclass{beamer}
\usetheme{Boadilla}
\usecolortheme{default}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{array}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{shapes.misc,shadows}
\usetikzlibrary{quotes,positioning,arrows,decorations.markings}
\usetikzlibrary{positioning} 
\usepackage[cache=false,section]{minted}
%\usepackage[a4paper, total={6in, 8in}]{geometry}
\usepackage[tworuled,algosection,figure,linesnumbered]{algorithm2e}
\usepackage{glossaries}
\usemintedstyle{default}
\newminted{haskell}{frame=lines,framerule=2pt}
\newminted{R}{frame=lines,framerule=2pt}
\graphicspath{{./images/}}
\newcommand{\DP}{\mathsf{DP}}
\newcommand{\dpwcc}{\mathsf{DP_{WCC}}}
\newcommand{\iwcc}{\mathsf{Sr}}
\newcommand{\iwc}{\mathsf{Sr_{WCC}}}
\newcommand{\owcc}{\mathsf{Sk}}
\newcommand{\owc}{\mathsf{Sk_{WCC}}}
\newcommand{\fwcc}{\mathsf{F}} 
\newcommand{\fwc}{\mathsf{F_{WCC}}} 
\newcommand{\gwcc}{\mathsf{G}}
\newcommand{\gwc}{\mathsf{G_{WCC}}}
\newcommand{\ice}{\mathsf{IC_E}}
\newcommand{\csofv}{\mathsf{IC_{set(V)}}}
\newcommand{\sgen}{\mathsf{S_G}}
\newcommand{\sfilter}{\mathsf{S_F}}
\newcommand{\sinp}{\mathsf{S_I}}
\newcommand{\sout}{\mathsf{S_O}}
\newcommand{\istream}{\mathsf{D}}
\newcommand{\wccout}{\mathsf{R}}
\newcommand{\fmem}{\mathsf{M_F}}
\newcommand{\eof}{\mathsf{eof}}
\newcommand{\Act}{\mathsf{actor_1}}
\newcommand{\Actt}{\mathsf{actor_2}}


\makeatletter
\long\def\beamer@author[#1]#2{%
  \def\insertauthor{\def\inst{\beamer@insttitle}\def\and{\beamer@andtitle}%
  \begin{tabular}{rl}#2\end{tabular}}%
  \def\beamer@shortauthor{#1}%
  \ifbeamer@autopdfinfo%
    \def\beamer@andstripped{}%
    \beamer@stripands#1 \and\relax
    {\let\inst=\@gobble\let\thanks=\@gobble\def\and{, }\hypersetup{pdfauthor={\beamer@andstripped}}}
  \fi%
}
\makeatother

\makeatletter
\pgfdeclareshape{datastore}{
  \inheritsavedanchors[from=rectangle]
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{south east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{north west}
  \backgroundpath{
    %  store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathmoveto{\pgfpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathlineto{\pgfpoint{\pgf@xb}{\pgf@yb}}
 }
}
\makeatother

\title[DP in Haskell]{Towards a Dynamic Pipeline Framework implemented in (parallel) Haskell}

\author[Royo Sales et al. (PROLE2021)] 
{%
  Juan Pablo Royo Sales\inst{1} \and Edelmira Pasarella\inst{1}\\
  Cristina Zoltan\inst{1} \and Maria-Esther Vidal\inst{2}
}

\institute[] % (optional)
{
  \inst{1}%
  Universitat Politecnica de Catalunya\\
  juan.pablo.royo@upc.edu\\
  \{zoltan,edelmira\}@cs.upc.edu \and
  \inst{2}%
  TIB/L3S Research Centre at the University of Hannover\\
  maria.vidal@tib.eu
  }
  
  \date[September 24, 2021] % (optional)
  {September 24, 2021}
  
  \titlegraphic{
    \begin{tikzpicture}[overlay,remember picture]
      \node[left=0.2cm] at (current page.30){
        \includegraphics[height=1cm]{upc_logo}
        \hspace{2cm}
        %
        \hspace{2cm}
        \includegraphics[height=1cm]{tib_logo}
      };
      \end{tikzpicture}
  }
  
  
  \begin{document}

  \begin{frame}
    \vspace{1.2cm}
    \titlepage
  \end{frame}

  \begin{frame}{Agenda}
    \tableofcontents
  \end{frame}
  
  \begin{frame}{Agenda}
    \section{Motivation}
    \tableofcontents[currentsection]
  \end{frame}

  \begin{frame}[fragile]{Motivation}
    Using an \textbf{FP Language} to build a \textbf{Dynamic Pipeline Framework}
  \end{frame}

  \begin{frame}[fragile]{Motivation}
    Using an \textbf{FP Language} to build a \textbf{Dynamic Pipeline Framework}

    \begin{block}

      \begin{itemize}
        \item \textbf{Haskell}: 
        \begin{itemize}
          \item Pure FP Language
          \item Strong theoretical foundations
          \item Toolset for building Multithreading Programs
        \end{itemize}
      \end{itemize}
      
    \end{block}
  \end{frame}
  
  \begin{frame}[fragile]{Motivation}
    Using an \textbf{FP Language} to build a \textbf{Dynamic Pipeline Framework}

    \begin{block}

      \begin{itemize}
        \item \textbf{Haskell}: 
        \begin{itemize}
          \item Pure FP Language
          \item Strong theoretical foundations
          \item Toolset for building Multithreading Programs
        \end{itemize}
        \item Experimental approach solving \textbf{WCC} to empirically test our assumptions
      \end{itemize}

    \end{block}
  \end{frame}

  \begin{frame}[fragile]{Motivation}
    Using an \textbf{FP Language} to build a \textbf{Dynamic Pipeline Framework}

    \begin{block}

      \begin{itemize}
        \item \textbf{Haskell}: 
        \begin{itemize}
          \item Pure FP Language
          \item Strong theoretical foundations
          \item Toolset for building Multithreading Programs
        \end{itemize}
        \item Experimental approach solving \textbf{WCC} to empirically test our assumptions
        \item Build a first approach of a \textbf{DP Framework in Haskell}
      \end{itemize}

    \end{block}
  \end{frame}

  \begin{frame}{Agenda}
    \section{Dynamic Pipeline Paradigm}
    \tableofcontents[currentsection]
  \end{frame}

  \input{genericDP-Fig}
  \begin{frame}[fragile]{Dynamic Pipeline Paradigm}
    \input{genericDP-Fig-1}
  \end{frame}

  \begin{frame}[fragile]{Dynamic Pipeline Paradigm}
    \input{genericDP-Fig-1}
    \input{genericDP-Fig-2}
  \end{frame}   

  \begin{frame}[fragile]{Dynamic Pipeline Paradigm}
    \input{genericDP-Fig-1}
    \input{genericDP-Fig-2}
    \input{genericDP-Fig-3}
  \end{frame}   

  \begin{frame}[fragile]{Dynamic Pipeline Paradigm}
    \input{genericDP-Fig-4}
  \end{frame}   

  \begin{frame}[fragile]{Dynamic Pipeline Paradigm}
    \input{genericDP-Fig-4}
    \input{genericDP-Fig-5}
  \end{frame}   

  \begin{frame}{Agenda}
    \section{DP Framework: Haskell}
    \tableofcontents[currentsection]
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \begin{center}
      \includegraphics[width = 0.6\textwidth, height = 0.8\textheight]{dpf_haskell_v3}
    \end{center}
  \end{frame}
  
  \begin{frame}[fragile]{DP Framework: Haskell}
    \begin{center}
      \includegraphics[width = 0.6\textwidth, height = 0.8\textheight]{dpf_haskell_v3-1}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \begin{center}
      \includegraphics[width = 0.6\textwidth, height = 0.8\textheight]{dpf_haskell_v3-2}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \begin{center}
      \includegraphics[width = 0.6\textwidth, height = 0.8\textheight]{dpf_haskell_v3-3}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \textbf{Focus on IDL}

    \begin{block}{}
      Library released on Hackage \\
      https://hackage.haskell.org/package/dynamic-pipeline
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \textbf{Focus on IDL}

    \begin{block}

      \begin{itemize}
        \item \textbf{DP Monad}: 
        \begin{itemize}
          \item Monad with Existential type to not scape DP Context. (\textit{Rank-2 Polymorphic type})
          \item Associativity Monad law guarantees execution flow (\mintinline{haskell}{ source >>= generator >>= sink }) 
        \end{itemize}
      \end{itemize}
      
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \textbf{Focus on IDL}

    \begin{block}

      \begin{itemize}
        \item \textbf{DP Monad}: 
        \begin{itemize}
          \item Monad with Existential type to not scape DP Context. (\textit{Rank-2 Polymorphic type})
          \item Associativity Monad law guarantees execution flow (\mintinline{haskell}{ source >>= generator >>= sink }) 
        \end{itemize}
        \item \textbf{Filter / Stage}: 
        \begin{itemize}
          \item Use of \mintinline{haskell}{unfold} to generate dynamic filter computations (\textit{Anamorphism})
          \item Use of \mintinline{haskell}{fold} to reduce results to Sink (\textit{Catamorphism})
        \end{itemize}
      \end{itemize}
      
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \textbf{Focus on IDL}

    \begin{block}

      \begin{itemize}
        \item \textbf{DP Monad}: 
        \begin{itemize}
          \item Monad with Existential type to not scape DP Context. (\textit{Rank-2 Polymorphic type})
          \item Associativity Monad law guarantees execution flow (\mintinline{haskell}{ source >>= generator >>= sink }) 
        \end{itemize}
        \item \textbf{Filter / Stage}: 
        \begin{itemize}
          \item Use of \mintinline{haskell}{unfold} to generate dynamic filter computations (\textit{Anamorphism})
          \item Use of \mintinline{haskell}{fold} to reduce results to Sink (\textit{Catamorphism})
        \end{itemize}
        \item \textbf{Parallelization}: \mintinline{haskell}{ async } library
      \end{itemize}
      
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{DP Framework: Haskell}
    \textbf{Focus on IDL}

    \begin{block}

      \begin{itemize}
        \item \textbf{DP Monad}: 
        \begin{itemize}
          \item Monad with Existential type to not scape DP Context. (\textit{Rank-2 Polymorphic type})
          \item Associativity Monad law guarantees execution flow (\mintinline{haskell}{ source >>= generator >>= sink }) 
        \end{itemize}
        \item \textbf{Filter / Stage}: 
        \begin{itemize}
          \item Use of \mintinline{haskell}{unfold} to generate dynamic filter computations (\textit{Anamorphism})
          \item Use of \mintinline{haskell}{fold} to reduce results to Sink (\textit{Catamorphism})
        \end{itemize}
        \item \textbf{Parallelization}: \mintinline{haskell}{ async } library
        \item \textbf{Channels}: \mintinline{haskell}{ unagi-chan } library
      \end{itemize}
      
    \end{block}
  \end{frame}

  \begin{frame}{Agenda}
    \section{$DP_{WCC}$: Computing $WCC$}
    \tableofcontents[currentsection]
  \end{frame}

  \begin{frame}[fragile]{$DP_{WCC}$: Computing $WCC$}
    \begin{block}{Program}
      \begin{minted}[fontsize=\tiny,numbers=left,framesep=2mm,baselinestretch=1.2]{haskell}      
type DPConnComp = Source (Channel (Edge :<+> ConnectedComponents :<+> Eof))
:=> Generator (Channel (Edge :<+> ConnectedComponents :<+> Eof))
:=> Sink

source' :: FilePath
        -> Stage
           (WriteChannel Edge -> WriteChannel ConnectedComponents -> DP st ())
source' filePath = withSource @DPConnComp
  $ \edgeOut _ -> unfoldFile filePath edgeOut (toEdge . decodeUtf8)

sink' :: Stage (ReadChannel Edge -> ReadChannel ConnectedComponents -> DP st ())
sink' = withSink @DPConnComp $ \_ cc -> withDP $ foldM_ cc print

generator' :: GeneratorStage DPConnComp ConnectedComponents Edge st
generator' =
  let gen = withGenerator @DPConnComp genAction
  in  mkGenerator gen filterTemplate

filterTemplate :: Filter DPConnComp ConnectedComponents Edge st
filterTemplate = actor actor1 |>> actor actor2

program :: FilePath -> IO ()
program file = runDP $ mkDP @DPConnComp (source' file) generator' sink'
      \end{minted}
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{$DP_{WCC}$: Computing $WCC$}
    \begin{block}{Actors}
      \begin{minted}[fontsize=\tiny,numbers=left,framesep=2mm,baselinestretch=1.2]{haskell}      
actor1 :: Edge -> ReadChannel Edge
       -> ReadChannel ConnectedComponents
       -> WriteChannel Edge
       -> WriteChannel ConnectedComponents
       -> StateT ConnectedComponents (DP st) ()
actor1 _ readEdge _ writeEdge _ = 
  foldM_ readEdge $ \e -> get >>= doActor e
 where
  doActor v conn
    | toConnectedComp v `intersect` conn = modify (toConnectedComp v <>)
    | otherwise = push v writeEdge

actor2 :: Edge
       -> ReadChannel Edge
       -> ReadChannel ConnectedComponents
       -> WriteChannel Edge
       -> WriteChannel ConnectedComponents
       -> StateT ConnectedComponents (DP st) ()
actor2 _ _ readCC _ writeCC = do 
  foldWithM_ readCC pushMemory $ \e -> get >>= doActor e

 where
   pushMemory = get >>= flip push writeCC
   doActor cc conn
    | cc `intersect` conn = modify (cc <>)
    | otherwise = push cc writeCC
      \end{minted}
    \end{block}
  \end{frame}

  \begin{frame}{Agenda}
    \section{Empirical Evaluation}
    \tableofcontents[currentsection]
  \end{frame}


  \begin{frame}[fragile]{Empirical Evaluation}
    \begin{block}{Experiments}
      \begin{itemize}
        \item \textbf{Implementation Analysis}: Measure and analyze Total execution time, MUT time and GC Time.
        \item \textbf{Benchmark Analysis}: Compare $DP_{WCC}$ with \mintinline{haskell}{Data.Graph} $WCC$ execution times:
        \begin{itemize}
          \item Using \mintinline{haskell}{ criterion } library.
          \item Diefficency metric $\mathtt{dief@t}$ (\textit{diepfy} tool) to measure incremental results.
        \end{itemize}
        \item \textbf{Performance Analysis}: Thread and Memory allocation analysis.
      \end{itemize}
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{Empirical Evaluation}
    \begin{block}{Graphs Tested}
    \begin{table}[H]
      \centering
      \begin{tabular}{|p{0.25\linewidth}|r|r|r|p{0.25\linewidth}|}
       \hline
       \textbf{Network} & \textbf{Nodes} & \textbf{Edges} & \textbf{\#WCC} & \textbf{\#Nodes Largest WCC} \\
       \hline
       Enron Emails & 36692 & 183831 & 1065 & 33696 (0.918) \\
       \hline
       Astro Physics Collaboration Net & 18772 & 198110 & 290 & 17903 (0.954)\\
       \hline
       Google Web Graph & 875713 & 5105039 & 2746 & 855802 (0.977)\\
       \hline
      \end{tabular}
     \end{table}
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{Empirical Evaluation}
    Criterion

    \begin{table}[H]
      \centering
      \begin{tabular}{|l|l|l|l|}
       \hline
       \textbf{Network} & \textbf{DP-Haskell} & \textbf{Data.Graph} & \textbf{Speed-up}\\
       \hline
       Enron Emails & 4.68s &  6.46s & 1.38\\
       \hline
       Astro Physics Coll Net & 4.98s & 6.95s  & 1.39\\
       \hline
       Google Web Graph & 386s & 106s & -3.64\\
       \hline
      \end{tabular}
     \end{table}

    \begin{minipage}[t]{\linewidth}
      \includegraphics[width=\textwidth]{bench_1}
    \end{minipage}

    Diefficency Metrics

      \begin{figure}[!htb]
        \centering
        \begin{minipage}{0.33\textwidth}
         \includegraphics[width=1\linewidth, height=0.2\textheight]{email_enron}
        \end{minipage}%
        \begin{minipage}{0.33\textwidth}
         \includegraphics[width=1\linewidth, height=0.2\textheight]{ca_astroph}
        \end{minipage}%
        \begin{minipage}{0.33\textwidth}
         \includegraphics[width=1\linewidth, height=0.2\textheight]{web_google}
        \end{minipage}
    \end{figure}
    
  \end{frame}

  \begin{frame}[fragile]{Empirical Evaluation}

    \begin{figure}[!htb]
      \centering
      \begin{minipage}{0.48\textwidth}
       \includegraphics[width=1\linewidth, height=0.5\textheight]{screen_2}
       \caption{ThreadScope}
      \end{minipage}%
      \begin{minipage}{0.48\textwidth}
         \includegraphics[width=1\linewidth, height=0.5\textheight]{visualization}
         \caption{Eventlog}
      \end{minipage}
     \end{figure}

  \end{frame}


  \begin{frame}{Agenda}
    \section{Conclusions and Future Work}
    \tableofcontents[currentsection]
  \end{frame}

  \begin{frame}[fragile]{Conclusions and Future Work}
    \begin{block}{Conclusions}      
      \begin{itemize}
        \item \textbf{Robustness and Suitability} of the DP-Haskell 
      \end{itemize}
    \end{block}
  \end{frame}

  \begin{frame}[fragile]{Conclusions and Future Work}
    \begin{block}{Conclusions}      

    \begin{itemize}
      \item \textbf{Robustness and Suitability} of the DP-Haskell 
      \item \textbf{Ability to generate Incremental results} has been shown by $\mathtt{dief@t}$ metrics 
    \end{itemize}
  \end{block}
  \end{frame}

  \begin{frame}[fragile]{Conclusions and Future Work}
    \begin{block}{Conclusions}      

    \begin{itemize}
      \item \textbf{Robustness and Suitability} of the DP-Haskell 
      \item \textbf{Ability to generate Incremental results} has been shown by $\mathtt{dief@t}$ metrics
      \item \textbf{Satisfactory Performance results} with an adequate Memory allocation and Execution times. 
    \end{itemize}
  \end{block}
  \end{frame}

  \begin{frame}[fragile]{Conclusions and Future Work}
    \begin{block}{Future work}      
    \begin{itemize}
      \item \textbf{Explore other Algorithms} to be implemented with this Paradigm.\footnote{We are currently working on Bi-partite Graphs algorithms}
      \item \textbf{Improve DP Framework} implementing more combinators and abstractions to allow the user write better and faster programs.
    \end{itemize}
  \end{block}
  \end{frame}

  \end{document}