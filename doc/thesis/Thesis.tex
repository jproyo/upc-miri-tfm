\documentclass[thesis]{Thesis}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{array}
\usepackage{graphicx}
\usepackage[pdfencoding=auto]{hyperref}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listings}
\usepackage{color}
\usepackage{caption}
\usepackage{authblk}
\usepackage{longtable}
\usepackage{paralist}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage[square, numbers, comma, sort&compress]{natbib}
\usepackage[ruled,linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=false]{minted}
\usetikzlibrary{shapes.misc,shadows}
\usetikzlibrary{quotes,positioning,arrows,decorations.markings}
\usetikzlibrary{positioning} 
\usemintedstyle{default}
\newminted{haskell}{frame=lines,framerule=2pt}
\newminted{R}{frame=lines,framerule=2pt}
\graphicspath{{./images/}}

\tikzstyle{bag} = [align=center]

\title{An incremental algorithm for enumerating bi-triangles in large bi-partite networks}
\setthesistype{Master}
\author{Juan Pablo Royo Sales}
\degree{Master in Innovation and Research in Informatics - Advance Computing}
\supervisor{Dra. Edelmira Pasarella}
\cosupervisor{Prof. Dra. Maria-Esther Vidal}
\cosupervisorb{Prof. Dra. Cristina Zoltan}

\date\today

\newcommand{\dw}{\mathbb{DW}}
\newcommand{\aw}{\mathbb{AW}}
\newcommand{\bt}{\mathbb{BT}}
\newcommand{\bti}{BT_{(l_1, l_2,l_3)}^{(u_1, u_2, u_3)}}
\newcommand{\at}{\mathbb{AT}}
\newcommand{\st}{ST}
\newcommand{\sw}{\mathtt{spawn}}
\newcommand{\fd}{\mathtt{killFilter}}
\newcommand{\fid}{\mathtt{filterIsDied}}
\newcommand{\us}{\mathtt{updateState}}
\newcommand{\gs}{\mathtt{getState}}
\newcommand{\p}{\mathtt{push}}
\newcommand{\mt}{\mathtt{matchQ}}
\newcommand{\io}{\mathtt{indexOf}}
\newcommand{\la}{\left\langle}
\newcommand{\ra}{\right\rangle}
\newcommand{\DP}{\mathsf{DP}}
\newcommand{\dpwcc}{\mathsf{DP_{WCC}}}
\newcommand{\iwcc}{\mathsf{Sr}}
\newcommand{\iwc}{\mathsf{Sr_{WCC}}}
\newcommand{\owcc}{\mathsf{Sk}}
\newcommand{\owc}{\mathsf{Sk_{WCC}}}
\newcommand{\fwcc}{\mathsf{F}} 
\newcommand{\fwc}{\mathsf{F_{WCC}}} 
\newcommand{\gwcc}{\mathsf{G}}
\newcommand{\gwc}{\mathsf{G_{WCC}}}
\newcommand{\ice}{\mathsf{IC_E}}
\newcommand{\csofv}{\mathsf{IC_{set(V)}}}
\newcommand{\sgen}{\mathsf{S_G}}
\newcommand{\sfilter}{\mathsf{S_F}}
\newcommand{\sinp}{\mathsf{S_I}}
\newcommand{\sout}{\mathsf{S_O}}
\newcommand{\istream}{\mathsf{D}}
\newcommand{\wccout}{\mathsf{R}}
\newcommand{\fmem}{\mathsf{M_F}}
\newcommand{\eof}{\mathsf{eof}}
\newcommand{\Act}{\mathsf{actor_1}}
\newcommand{\Actt}{\mathsf{actor_2}}


\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}

\newacronym{bt}{BT}{Bitriangle}
\newacronym{bg}{BG}{Bipartite Graph}
\newacronym{ug}{UG}{Unipartite Graph}
\newacronym{dp}{DPP}{Dynamic Pipeline Paradigm}
\newacronym{dpf}{DPF}{Dynamic Pipeline Framework}
\newacronym{dpbt}{DP-BT-Haskell}{$DP_{BT}$ in Haskell}
\newacronym{dpwcc}{DP-WCC-Haskell}{$DP_{WCC}$ in Haskell}
\newacronym{dpl}{DPL}{dynamic-pipeline Library}
\newacronym{bfs}{BFS}{Breadth-First Search}
\newacronym{dfs}{DFS}{Depth-First Search}
\newacronym{wcc}{WCC}{Weak Connected Components}
\newacronym{hs}{Haskell}{Haskell Programming Language}
\newacronym{fp}{FP}{Functional Programming}
\newacronym{stm}{STM}{Software Transactional Memory}
\newacronym{rl}{R}{R Language}
\newacronym{os}{OS}{Operative System}
\newacronym{dm}{Dm}{Diefficency Metrics}
\newacronym{tfft}{TFFT}{Time for the first tuple}
\newacronym{et}{ET}{Execution Time}
\newacronym{comp}{Comp}{Completeness}
\newacronym{tt}{T}{Throughput}
\newacronym{dt}{dief$@$t}{Diefficiency first $t$ time units}
\newacronym{snap}{SNAP}{Stanford Network Data Set Collection}
\newacronym{ghc}{GHC}{Glasgow Haskell Compiler}
\newacronym{dsl}{DSL}{Domain-specific Language}
\newacronym{edsl}{EDSL}{Embedded Domain-specific Language}
\newacronym{idl}{IDL}{Interpreter of DSL}
\newacronym{rs}{RS}{Runtime System}
\newacronym{go}{Go}{Go Programming Language}
\newacronym{hl}{HL}{Host Language}

\glsdisablehyper

\newtheorem{hyp}{Hypothesis}


\begin{document}

\maketitle

\cleardoublepage
% The "Quote Page"
%%%\pagestyle{empty}  % No headers or footers for the following pages
\null\vfill
\textit{".. when a Mathematical Reasoning can be had it's as great a folly to make use of any other, as to grope for a thing in the dark, when you have a Candle standing by you."}
\begin{flushright}
	Of the Laws of Chance, John Arbuthnot (1662)\\
\end{flushright}
\vfill\vfill\vfill\vfill\vfill\vfill\null
\cleardoublepage 

\rhead{\thepage}
\pagestyle{fancy}
\tableofcontents
\listoffigures
\listoftables
\mainmatter

\acknowledgements{
  Thanks to ...... % TODO
}

\abstract{
A bipartite network is a graph with two disjoint vertex sets where its edges only connect vertices from different sets. For instance, two different sets of objects can be modeled with this, establishing the relationships between them (e.g. a network of drugs and side effects of those drugs). 
One of the metrics, that reflect accurately if the relationships are strong on particular elements of the sets, is bi-triangles of bipartite graphs. Although it is known that enumerating those bi-triangles is an NP-complete problem,
having an incremental algorithm that provides incremental results for enumerating bi-triangles that matches specific criteria,
are extremely useful for real networks and scenarios like expressed before. 
On the other hand, streaming processing has given rise to new computation paradigms to provide effective and efficient data stream processing.
The most important features of these new paradigms are the exploitation of parallelism, the capacity to adapt execution schedulers, 
reconfigure computational structures, adjust the use of resources according to the characteristics of the input stream and produce incremental results. 
The Dynamic Pipeline Paradigm (DPP) is a naturally functional approach to deal with stream processing. 
This fact encourages us to use Haskell, a purely functional programming language, for DPP.  
In this work, we tackle the problem of assessing the suitability of using (parallel) Haskell to implement a Dynamic Pipeline Framework (DPF). 
After that, we show the abstraction and implementation details of the DP Framework written in Haskell and then, 
we provide an algorithm for enumerating bi-triangles in a bi-partite graph given particular criteria. 
At the end of the work, we empirically evaluate the implementation against large bipartite networks through a series of experiments and metrics and discuses
the conclusions that we arrive at based on these experiments' results.
All these results are novel and cannot be compared with related works since they focused on counting problems and not enumeration.
}

\input{chapters/chapter_1.tex}
\input{chapters/chapter_2.tex}
\input{chapters/chapter_3.tex}
\input{chapters/chapter_4.tex}
\input{chapters/chapter_5.tex}
\input{chapters/chapter_6.tex}
\input{chapters/chapter_7.tex}
\input{chapters/chapter_8.tex}

\bibliographystyle{unsrtnat}
\bibliography{Thesis}

\appendix

\end{document}

