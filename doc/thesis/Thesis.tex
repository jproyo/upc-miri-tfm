\documentclass[thesis]{Thesis}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{array}
\usepackage{graphicx}
\usepackage[pdfencoding=auto]{hyperref}
\usepackage{fancyvrb}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{float}
\usepackage{listing}
\usepackage{color}
\usepackage{caption}
\usepackage{authblk}
\usepackage{longtable}
\usepackage{paralist}
\usepackage{wrapfig}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage[square, numbers, comma, sort&compress]{natbib}
\usepackage[ruled,linesnumbered,lined,boxed,commentsnumbered]{algorithm2e}
\usepackage[acronym]{glossaries}
\usepackage[nottoc]{tocbibind}
\usepackage[cache=true]{minted}

\title{An algorithm for incrementally enumerating bitriangles in large bipartite networks}
\setthesistype{Master}
\author{Juan Pablo Royo Sales}
\degree{%
  Master in Innovation and Research in Informatics\\ 
  Advance Computing
}
\supervisor{%
  Edelmira Pasarella, Computer Science Department\newline
  Maria-Esther Vidal, Leibniz Information Centre for Science and Technology-TIB, and L3S Centre at the Leibniz University of Hannover\newline
  Cristina Zoltan, Computer Science Department
}

\date{Octuber, 2021}

\input{misc/header.tex}

\tikzexternalize[shell escape=-shell-escape,mode=graphics if exists,prefix=images/]
\begin{document}

\maketitle

\cleardoublepage
% The "Quote Page"
%%%\pagestyle{empty}  % No headers or footers for the following pages
\null\vfill
\textit{".. when a Mathematical Reasoning can be had it's as great a folly to make use of any other, as to grope for a thing in the dark, when you have a Candle standing by you."}
\begin{flushright}
	Of the Laws of Chance, John Arbuthnot (1662)\\
\end{flushright}
\vfill\vfill\vfill\vfill\vfill\vfill\null
\cleardoublepage 

\rhead{\thepage}
\pagestyle{fancy}
\tableofcontents
\listoffigures
\listoftables
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithm}
\listoflistings
\addcontentsline{toc}{chapter}{List of Source Code}
\mainmatter

\acknowledgements{
  Thanks to ...... % TODO
}

\abstract{
A bipartite network is a graph with two disjoint vertex sets where its edges only connect vertices from different sets. 
For instance, two different object sets can be modeled with a bipartite graph, establishing the relationships between them (e.g., a network of drugs and side effects of those drugs, a network of TV Shows and its subscriptors, diseases gene association network and many more). 
In Unipartite graph, one of the metrics that reflects strong relationships on elements is triangles. This minimal unit of cohesion in unipartite graph helps to analyze this type of networks, measuring different parameters such as clustering coeficient, social analysis or triangle-based communities.
Alghouth Bipartite Graphs does not have such element of measure, there exists a similar smallest unit of cohesion which is the Bitriangle. This metrics also allows to analyze Bipartite Networks in terms of the same parameters as unipartite graph for detecting strong relationships between sets of vertices.
Some related work has been done in for counting Bitriangles in Bipartite Graph lately. In spite counting is extremely useful for calculating previous described parameters such as clustering coeficient, there are some use cases which requires the capability to know structural information of those Bitriangles, 
for example in disorder/disease gene association networks where it is important to know the gene causing the disease.
Moreover, depending on the size of the graph enumerating bitriangles could be a high-resource consuming task and an "all-or-nothing" computation model might not deliver any result at all. In the opposite, a \emph{pay-as-you-go} computational model approach can be provided giving the fact the user is able to conduct analysis as long as it receives some results without waiting the for rest of them.
In that sense, an Algorithm that Enumerates Bitriangles incrementally matching a specific criteria is extremely useful and powerful for real networks and scenarios like expressed before. 
Streaming processing has given rise to new computation paradigms processing data effectively.
The most important features of these paradigms are the exploitation of parallelism, the capacity to adapt execution schedulers, 
reconfigure computational structures, adjust the use of resources according to the characteristics of the input stream and produce incremental results. 
The Dynamic Pipeline Paradigm (DPP) is a naturally functional approach to deal with stream processing. 
This fact encourages us to use Haskell, a purely functional programming language, for DPP.  
In this work, we tackle the problem of providing an Algorithm for Incrementally Enumerating Bitriangles in large Bipartite Networks, following the next steps:
  \begin{inparaenum}[\bf i\upshape)]
      \item We validate the suitability of (parallel) Haskell to implement a Dynamic Pipeline Framework (DPF).
      \item Then, we provide the abstraction and implementation details of a general purpose Dynamic Pipeline Framework written in Haskell.
      \item We define, implement and provide a correctness analysis of an Algorithm for Incrementally Enumerating Bitriangles in large Bipartite Networks. 
      \item Finally, we empirically evaluate the implementation of the algorithm against large bipartite networks through a series of experiments and discuss the conclusions that we reach analyzing the empirical data.
  \end{inparaenum}%
}

\input{chapters/chapter_1.tex}
\input{chapters/chapter_2.tex}
\input{chapters/chapter_3.tex}
\input{chapters/chapter_4.tex}
\input{chapters/chapter_5.tex}
\input{chapters/chapter_6.tex}
\input{chapters/chapter_7.tex}
\input{chapters/chapter_8.tex}

\appendix
\input{chapters/appendix.tex}

\bibliographystyle{unsrtnat}
\bibliography{Thesis}

\end{document}

