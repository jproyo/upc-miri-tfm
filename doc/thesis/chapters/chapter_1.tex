\chapter{Introduction}\label{intro}
\section{Motivation}
A \acrfull{bg} is a graph with two disjoint vertex sets where its edges only connect vertices from different sets. 
For instance, two different sets of objects can be modeled with a \acrshort{bg}, establishing the relationships between them.
There are different use cases in which we can take advantage of a \acrshort{bg} representation and detect how the elements between the sets
are related. For example, coding theory~\cite{DBLP:journals/corr/WangL13} to represent the relationships between words in code or graphs in hypergraph theory~\cite{hypergraph}. 
Another important field that can be modeled with \acrshort{bg} is pharmacology research, for establishing the relation between the drugs and side effects~\cite{drugs}.

To detect the underlying relations of the components of the different sets in a \acrshort{bg} we have at our disposal the same metrics as we have in \acrfull{ug}.
Unfortunately most of those metrics in \acrshort{ug} like clustering coefficient, social analysis or triangle-based community computation~\cite{ccoef,detect_graph,Newman_2003},
are based on computing the number of triangles in the network. Obtaining those metrics on \acrshort{bg} requires to count \acrfull{bt} on \acrshort{bg}.
In that matter, there has been a novel work that provides efficient algorithms to count \acrshort{bt} in $P$~\cite{btcount}.

On the other hand, there exists another kind of relationship in \acrshort{bg} that cannot be obtained only by counting \acrshort{bt} and requires knowing specific
structural details. One of those relations are motif-paths~\cite{Li2019MotifPA}, in particular, a \acrshort{bt} can be seen as a motif. To detect a path between different motifs, we could potentially enumerate \acrshort{bt} and check how they are connected.
Moreover an enumeration algorithm might not terminate if the \acrshort{bg} contains millions of \acrshort{bt}. For overcoming this problem, users might want to query or request some \acrshort{bt} that follows certain criteria, reducing the search space. 
This leads us to the main motivation of this work which is to provide an incremental algorithm to enumerate \acrlong{bt} in \acrlong{bg}.

Regarding the possible implementations of this kind of algorithm and taking into consideration the need of delivering incremental results to the user, 
we believe that the incremental \acrshort{bt} enumeration problem should be addressed with a parallel streaming model.
Streaming processing has given rise to new computation paradigms to provide effective and efficient data stream processing.
The most important features of these new paradigms are the exploitation of parallelism, the capacity to adapt execution schedulers, 
reconfigure computational structures, adjust the use of resources according to the characteristics of the input stream and produce incremental results. 
The \acrfull{dp} is a naturally functional approach to deal with stream processing. 
This fact encourages us to use \acrlong{hs}, a purely functional programming language, for \acrshort{dp}.

In conclusion, taking advantage of this computational model we can design an incremental algorithm to enumerate \acrshort{bt} in \acrshort{bg}.

\section{Problem Statement}
Before presenting the statement problem, we should previously provide some definitions.

\begin{definition}[\acrlong{bg}] 
A bipartite graph is an undirected graph $G=(V,E)$  such that $V=(U\cup L)$, $U\cap L=\emptyset$ and $E\subseteq U\times L$.\cite{Bondy1976}
\end{definition}

Additionally, without loss of generality, we assume that  $U\subseteq \mathbb{N}$ and $L\subseteq \mathbb{N}$. Consequently, $(U,<)$  and $(L,<)$ are strict total orders. We can see an example of a \acrshort{bg}
in \autoref{fig:bipartite-graph-example}.

\begin{figure}[ht]
\centering	
\inputtikz{bipartite}
\caption{Example of \acrshort{bg}}
\label{fig:bipartite-graph-example}
\end{figure}

%
\begin{definition}[\acrlong{bt}]\label{def:bt}
Let $G=((U\cup L),E)$ be a bipartite graph. Let the triples $\mu=(u_1, u_2, u_3)$ and $\ell=(l_1, l_2,l_3)$ on $U$ and $L$, respectively, i.e.  $\{u_1, u_2, u_3\} \subseteq U$, $\{l_1, l_2,l_3\} \subseteq L$. 
The 6-cycle $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$  is a \textit{bi-triangle} in $G$, denoted by $BT_{\ell}^{\mu} = \bti$. 
\end{definition}

\begin{figure}[htp!]
\begin{subfigure}[b]{0.5\textwidth}
\centering
\inputtikz{bitriangle}
\caption{Example of \acrshort{bt} in \acrshort{bg}}
\label{fig:bitriangle-example}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\centering
\inputtikz{not-bitriangle}
\caption{Not a \acrshort{bt} in \acrshort{bg}}
\label{fig:bitriangle-not}
\end{subfigure}
\end{figure}

In \autoref{fig:bitriangle-example} we can see a correct \acrshort{bt} in a \acrshort{bg}, and in the other \autoref{fig:bitriangle-not} we can see what it is not a \acrshort{bt}.

\begin{definition}[Query]
Let $G=((U\cup L),E)$ be a bipartite graph. 
A \textit{query} $Q$ is a sum type $Q = Q_V + Q_E$, where $Q_V \subseteq (U \cup L)$ and $Q_E \subseteq E$. 
It could be a query of vertices or edges.
\end{definition}

\begin{definition}[Query Match]
  Let $G=((U\cup L),E)$ be a bipartite graph.
  Let $Q$ be a query.
  A query $Q$ matches in a bipartite graph $G$ if forall $BT_{(l_1,l_2,l_3)}^{(u_1,u_2,u_3)}$ of $G$
  \[
    Q = \left\{\begin{array}{lr}
      Q_V, & \forall\ v \in Q_V, v \in \{u_1,u_2,u_3,l_1,l_2,l_3\}\\
      Q_E, & \forall\ (u,l) \in Q_E, (u,l) \in \{(u_1, l_1), (u_2,l_1), (u_2, l_3), (u_3,l_3), (u_3, l_2), (u_1,l_2)\} 
      \end{array}\right\} 
  \]
  \end{definition}
  
\paragraph{Statement:}Given a \acrlong{bg} $G$ and a query $Q$, incrementally enumerate all the \acrlong{bt} $BT_{\ell}^{\mu}$ that matches query $Q$.

\section{Proposed Solution}
The solution proposed in this work is implementing this algorithm using \acrfull{dp} implemented in \acrfull{hs}.
In order to achieve that goal, we first conduct a proof of concept to assess the feasibility of using \acrshort{hs} for implementing an algorithm with the \acrshort{dp}.
In that assessment, we work on solving the problem of \acrfull{wcc} of a graph. Then, we develop a \acrlong{dpf} written in \acrlong{hs} that could help to implement any algorithm using \acrshort{dp}.
Following that, we provide the formal definition of an algorithm for incrementally enumerate \acrshort{bt} using \acrshort{dp}, in a pseudo-code format. 
Finally, we provide correctness proof of the algorithm plus the implementation using the \acrshort{dpf} in \acrshort{hs}, that we call \acrfull{dpbt}.

\section{Contribution}\label{sec:contrib}
One of the main contributions we made was the presentation of a paper in the \acrfull{prole21} Conference~\cite{prole21}. 
On the first hand, the motivation that triggers that contribution was to assess the suitability of \acrshort{hs} to implement \acrshort{dp}. 
On the second hand, and in order to verify that \acrshort{hs} fits \acrshort{dp} requirements, we made a proof of concept solving \acrfull{wcc} of a Graph 
using \acrshort{dp} with \acrshort{hs}.

Moreover another important contribution, and as a result of \acrshort{prole21} work, was the development and publication of a \acrshort{hs} Framework 
called \mintinline{shell}{dynamic-pipeline}~\cite{dynamic-pipeline}. The framework was published on \acrfull{hack}~\cite{hackage} on 2021 June 17th in its first version,
providing to \acrshort{hs} community the ability to build algorithms using \acrshort{dp}. This is a novel contribution since it is the first library published on \acrshort{hs}
that implements \acrshort{dp}.

Finally, the novelty that provides an incremental algorithm for enumerating \acrshort{bt} is a step forward on the field and opens new research paths and improvements 
to be addressed in the future. 

\section{Document Overview}
This document is organized as follows. In \autoref{prelim} we present and describe all the previous work that has been done on the related fields of Streaming Processing, Dynamic Pipeline Paradigm, and Streaming processing related to \acrshort{hs}. 
Following that, in \autoref{relate-work} we describe the state of the art related \acrshort{bt} in \acrshort{bg} and incremental processing algorithms in general.
In \autoref{prole} we show and describe with some level of details, an overview to the \acrshort{prole21} as well as the details of the results obtained. 
Continuing with that, in \autoref{dp-hs} we deeply describe the \acrshort{dpf} written in \acrshort{hs}, the design of the framework, and all the used techniques for the implementation.
After that chapter, we finally arrive at \autoref{incr-algo-bt-dp} where we focus on the main problem of this work. There we provide all the details related to the incremental algorithm for enumerating \acrshort{bt} in \acrshort{bg}, its pseudo-code,
correctness proof and \acrshort{hs} implementation using the framework.
In \autoref{experiments} we describe the experimental analysis conducted to assert our assumptions and answer our research questions.
Finally, at the end of the document in \autoref{conclusions}, we present the future work and the conclusions obtained.

\section{Chapter Summary}
In this chapter, we have shown the motivation of this work, as well as the problem statement related to that motivation and the proposed solution to that problem.
We have also described how is going to be the organization of all the documents to facilitate the reader review.
