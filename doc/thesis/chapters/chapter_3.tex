\chapter{Related Work}\label{relate-work}
In this chapter, we present \emph{the state of the art} of \acrlong{bt} in \acrlong{bg} and incremental processing.
In the case of \acrshort{bt} in \acrshort{bg}, we show the last novel work that has been conducted but related to counting \acrshort{bt},
and in the case of incremental computations, we describe some of the last research that has been done in this model as well. 

\section{\acrlong{bt} Counting in \acrlong{bg}}
As we have stated on the \autoref{intro}, there is neither a previous work done on \acrshort{bt} enumeration nor a \acrshort{hs} Framework or Library that implements \acrshort{dp}.
A \acrshort{bt} is a Hamiltonian circuit as well, and finding Hamiltonian circuits in \acrshort{bg} is $NP$-complete~\cite{hamilbipartite-np}. On the other hand for counting \acrshort{bt} there is a novel \emph{polly-time} algorithm 
 in $P$ presented on this work~\cite{btcount}.

In that paper, the authors present different concepts to calculate with a combinatorial algorithmic the counting problem of \acrshort{bt} in \acrshort{bg}. They present three algorithms to count
all the \acrshort{bt} in the graph \emph{(Global Counting)}, and two algorithms to count only locally \acrshort{bt} \emph{(Local Counting)}: this means that given a vertex or an edge, the algorithms count only the number of \acrshort{bt} in which 
that vertex or edge is participating.

We are going to describe the most efficient algorithm of the first three that count all the \acrshort{bt} and the two local algorithms.

\subsection{Global Counting}
The first algorithmic approach authors introduced is \emph{wedge-based counting}. We do not cover this because it is discarded
by the authors in the empirical analysis, because the complexity is the highest of three and, it did perform well in the experimentation phase.

\paragraph{Super-wedge-based algorithm (SWJ-Count)}.
The principal idea of this algorithm relies on \emph{swj-unit} counting, which is a novel 
concept introduced in this work. A \emph{swj-unit} is a connected subgraph that is formed by two \emph{super-wedges}. A \emph{super-wedge}
is a 3-hop path. The authors shows that a \acrshort{bt} is a \emph{swj-unit} but not every \emph{swj-unit} is a \acrshort{bt}. Those 
are not \acrshort{bt} are \emph{acyclic swj-unit}. The main idea of the algorithm is to count all \emph{swj-unit} and the \emph{acyclic swj-unit}; therefore
the number of \acrshort{bt} can be deduced straightforward.

\paragraph{Results (SWJ-Count)} The authors present and do the analysis of the algorithm based on \emph{swj-unit} counting and they prove that the complexity is $O(\sum_{l \in L} (d(l)^2+d_3(l) + \sum_{x \in N_2(l)} d(x)) + \sum_{u \in U} d(u)^2)$.
Recall that $L \cup U = E$, $d(v)$ is the degree of the vertex $v$, $d_k(v)$ is the number of $k$-hop neighbors of $v$ and $N_2(v)$ the set of $k$-hop neighbors of $v$.
Therefore, the complexity is quadratic in the vertex with the highest degree, worst case.
In terms of empirical analysis, it performs well up to graphs of $4 \times 10^20$ bi-triangles. After that, the algorithm does not terminate.

\paragraph{Advantages (SWJ-Count)} The main advantage of this algorithm compared with the wedge-based is that it does not count wedges twice.
Therefore the complexity is less although both \emph{polly-time}.

\paragraph{Ranked Super-wedge based algorithm (RSWJ-Count)} This is a better approach compared with the previous in terms of complexity and running time because it takes the same gadget to count which is the \emph{swj-unit} but introducing ranking on the degree of the vertices. The main idea is that vertices with a higher degree have more super-wedges 
and therefore \emph{swj-unit} can be count faster by sharing computations.

\paragraph{Results (RSWJ-Count)} The complexity of this algorithm is $O(m + n + \sum_{v \in V} d(v)(\phi(v) + \phi_2(v)))$, where $\phi_k(v)$ is the abbreviation of $\Phi_k(\sigma(v), v)$. $\Phi_k(r, v)$ describe the subsets of $v$'s $k$-hop neighbors with ranks smaller than $r$.
In terms of empirical analysis, it performs slightly better than super-wedge-base but it cannot deal with graphs equal to or greater than $4 \times 10^20$ bi-triangles. The same as SWJ-Count.

\paragraph{Advantages (RSWJ-Count)} This is the best of all three algorithms for doing global counting.

\subsection{Local Counting}
Both algorithms to count locally \acrshort{bt} given a particular vertex or an edge, is based on the previous \emph{swj-unit} global algorithm, 
but instead of check every vertex, it only calculates from the one that is requested. 
In the case of vertex local counting given a vertex $v_0$, the complexity reduces to linear complexity worst case $O(d_3(v_0) \times \sum_{x \in N(v_0)} d(x) + \sum_{y \in N_2(v_0)} d(y))$.
In the case of edge local counting given an edge $e_0$, the complexity also reduces to linear complexity worst case $O(\sum_{x \in N(u) \cup N(l)} d(x) + \sum_{y \in N_2(y)} d(y))$.

\subsection{Conclusion}
Although the authors achieve both theoretical \emph{polly-time} complexity and empirical remarkable execution times for counting \acrshort{bt} in huge \acrshort{bg}, the enumeration problem is not addressed. 
Following that, we discarded the use some specific gadgets like \emph{super-wedges}, \emph{swj-unit} and \emph{wj-unit} because those hide the information of the \acrshort{bt}
form which is essential for enumeration.

\section{Incremental Computation}
The ability to deliver incremental results without waiting for the whole results is known as the \emph{pay-as-you-go} model. This plays a fundamental role in applications that needs to process big data. 
There have been different use cases in which this approach has helped to obtain partial results in large data set structures.

\paragraph{Fact-Checking} Some of these studies are related to \emph{Fact Checking Pay-as-you-go} models~\cite{factcatch} which use incremental quality estimation to provide fact-checking over world wide web documents.
Here, the authors require that it should continuously improve the credibility assessment of the documents in the database and, users may then examine the
that to decide whether to stop or resume validation.
For conducting this model, they propose a simple front-end application connecting with a backend that is communicating with a Database in PostgreSQL. 
The limitations of their model rely on any use of parallelization computation. Basically, they are relying on all the computational models to the Database system. 
We believe that an incremental approach or \emph{pay-as-you-go} model can be described and implemented better with a \acrshort{dp} model because all the processing is done in parallel. 
Another advantage of \acrshort{dp} model is that, once the data is computed, if we are in an unbounded data stream, we can receive more data to incrementally update and deliver results. 
In the case of \emph{fact-checking}, those updates could be new validations.

\paragraph{\emph{motif-paths}} Another important use of this model is found in \emph{motif-paths} work~\cite{Li2019MotifPA} like we discussed on previous \autoref{intro}.
Because of the complexity of building a \emph{motif-graph} to establish the shortest path, this path is search incrementally in an algorithm called \emph{Incremental Motif-path Search (IMS Search)}.
The idea of this algorithm is the following: After all the motif-graphs are discovered around some seed $s$, a motif-path $\mathbf{P}$ can be constructed based on those instances.
The process is repeated until a target $t$ node is discovered. According to the paper, this method has two limitations. First, it is possible to detect \emph{motif-path} that contains 
redundant \emph{motif-instances}. Secondly, the incremental search proposed might be far from the optimal direction. For the first issue, the authors proposed a pre-filter for the \emph{motif-instances},
and for the second one, a bi-directional search allowing to explore different seeds. 
In that sense, \acrshort{dp} can improve this incremental search first because it can provide a special filter for \emph{motif-instances} eliminating the need for filtering because the filter is built-in in the model itself.
Then, to deal with the optimal direction, \acrshort{dp} allows retro-feeding the pipeline more than once with more than one channel. This means that we are not only able to explore different seeds, but we also can do it in parallel as well.

\section{Chapter Summary}
In this chapter, we have summarized all the \emph{State of the Art} that are related to our research.
First, we have shown all the details of the most recent work regarding \acrlong{bt} in \acrlong{bg}.
Then, we have also explored, what are the latest research and explorations in the use of incremental computational models (\emph{pay-as-you-go}).
