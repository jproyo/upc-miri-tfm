\chapter[An Algorithm for Incrementally Enummerating Bitriangles]{An algorithm for incrementally enumerating Bitriangles using DP}\label{incr-algo-bt-dp}
In this chapter, we first describe the overall idea of the algorithm for incrementally enumerate 
\acrfull{bt}. After that, we present the algorithms in pseudo-code format and then a complexity analysis of the principal functions of the algorithm.
In the end, we provide the proof of correctness and the implementation using the \acrshort{dpfh}.  

\section{Preliminaries Definitions}\label{sec:prem:def}
In order to understand how the algorithm works, we need to provide some basic definitions that are already exposed in previous work~\cite{btcount}, and
at the same time, we define other structures that we use for giving a solution to the problem.
Let's enumerate all those definitions in the following paragraphs.

\begin{definition}[\acrlong{bg}] 
A \acrfull{bg} is an undirected graph $G=(V,E)$  such that $V=(U\cup L)$, $U\cap L=\emptyset$ and $E\subseteq U\times L$.\cite{Bondy1976}
\end{definition}

Additionally, without loss of generality, we assume that  $U\subseteq \mathbb{N}$ and $L\subseteq \mathbb{N}$. Consequently, $(U,<)$  and $(L,<)$ are strict total orders. We can see an example of a \acrshort{bg}
in \autoref{fig:bipartite-graph-example}.

\begin{figure}[ht]
\centering	
\inputtikz{bipartite}
\caption[{[\acrshort{iebt}] Example of \acrlong{bg}}]{Example of \acrlong{bg} which has $5$ (five) \acrshort{bt}. We are going to use this example to show how to build the different objects definitions presented in \autoref{sec:prem:def}}
\label{fig:bipartite-graph-example}
\end{figure}

As we can see in \autoref{fig:bipartite-graph-example}, trying to identify the different \acrshort{bt} in this graph, it can be done manually, but in larger graphs can be more challenging.
The minimal structure that we can extract from this \acrshort{bt} is \acrlong{awg}, but for that we need to define what is a \acrfull{wg}.

\begin{definition}[\acrfull{wg}]\label{def:wg}
A \textit{\acrfull{wg}} in $G$ is a triple $(u_1,l,u_2)$, $\{u_1,u_2\}\subseteq U$, $l \in L$ and $\{(u_1,l),$ $(l,u_2)\} \subseteq E$. The vertex $l$ is the middle vertex of the wedge. 
\end{definition}
With this \dref{def:wg} in place, we can now define a \acrshort{awg}, which is an aggregated form of all the wedges of one $l \in L$.
      
\begin{definition}[\acrfull{awg}]\label{def:awg}
An \textit{\acrfull{awg}} is a pair $\la l, W_l \ra$, where $l \in L$, $W_l \subseteq U$ and for all $u\in W_l$, the edge  $(u,l)\in E$. 
\end{definition}

\begin{figure}[htp!]
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_a}
\caption{\acrshort{awg} on $a$}
\label{fig:awedge-example-a}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_b}
\caption{\acrshort{awg} on $b$}
\label{fig:awedge-example-b}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_c}
\caption{\acrshort{awg} on $c$}
\label{fig:awedge-example-c}
\end{subfigure}
\caption[{[\acrshort{iebt}] Definitions Examples \acrlong{awg}}]{\acrlong{awg} of nodes $a,b,c$ of \autoref{fig:bipartite-graph-example}}
\label{fig:awedge-example}
\end{figure}

As we can see on \autoref{fig:awedge-example}, we are only enumerating the first three lower layer vertices \acrshort{awg}.
Following that, now we can define a more refined structure that will allow us to enrich the \acrshort{awg} in order to lead us to a \acrshort{bt}. 
That intermediate structure is an \acrlong{adwg}. For defining \acrshort{adwg} we need also another structure called \acrlong{dwg}. Intuitively is similar to \acrshort{wg} and \acrshort{awg} but relating two vertices in the Lower Layer $L$.

\begin{definition}[\acrfull{dwg}]
A \textit{\acrfull{dwg}} in $G$ is a path of length 4 $(u_1,l_1,u_2,l_2,u_3)$ where  $\{u_1,$ $u_2,u_3\}\subseteq U$ and $\{l_1,l_2\}\subseteq L$. Vertices $l_1$ and $l_2$ are the middle vertices of \acrshort{dwg}. 
\end{definition}
      
\begin{definition}[\acrfull{adwg}]\label{def:adwg}
Let $U_l = \la I, J, K\ra$ be a triplet such that $I \subseteq U, J \subseteq U$ and $K \subseteq U$, where $I, J$ and $K$ are disjoint sets. 
An \textit{\acrfull{adwg}}  is a pair  $\la (l_1, l_2), U_l \ra$, where $\{l_1,l_2\}\subseteq L$ and  for all $u_i \in I, u_j \in J$ and $u_k \in K$, $\{(u_i, l_1), (u_j, l_1), (u_j, l_2), (u_k, l_2)\} \in E$.
\end{definition}
      
\begin{figure}[htp!]
\centering
\inputtikz{bipartite_adwg_a}
\caption[{[\acrshort{iebt}] Example Aggregated double-wedge}]{\acrlong{adwg} of the pair of nodes $(a,c)$ of \autoref{fig:bipartite-graph-example}. Upper layer nodes $1,3,7$ and $5,9$ are enclosed in a Square indicating the set that they belong to. Remember in \dref{def:adwg} we are forming three sets $U_l = \la I, J, K \ra$. $I = \emptyset$ in this case because they should be disjoint sets and $a$ and $c$ share the same upper layer nodes in $J$.}
\label{fig:agg-double-wedge-example}
\end{figure}

In \autoref{fig:agg-double-wedge-example} we can see the \acrshort{adwg} built by $a$ and $c$ where according to \dref{def:adwg} $a = l_1$ and $c = l_2$.
The last aggregated structure that will finally enable the algorithm to build a \acrshort{bt} is an \acrlong{abt}. In \acrshort{abt} we need some other structure definitions before to understand how it is built, but intuitively it is an aggregation of a \acrshort{adwg} with another new \acrshort{awg} that is related with the former structure.

\begin{definition}[\acrfull{awgc}]\label{def:awgc}
Let $\la (l_1, l_2), U_l \ra$ be an \acrshort{adwg}, where $\{l_1,l_2\}\subseteq L$ and $U_l = \la I, J, K\ra$.
An \acrshort{awg} $\la l, W_l \ra$ is an \textit{\acrfull{awgc}} \emph{if and only if} $l > l_1$ and $l < l_2$ and $W_l \cap (I \cup J) \neq \emptyset$ and $W_l \cap (K \cup J) \neq \emptyset$
\end{definition}
      
\begin{definition}[\acrfull{abt}]\label{def:abt}
Let $\hat{U}_l=\la I, J, K\ra$, such that $I \subseteq U, J \subseteq U, K \subseteq U$. An \textit{\acrfull{abt}}  is a pair  $\langle \ell, \hat{U}_l\rangle$, 
where $\ell=(l_1, l_2, l_3)$ is a triple on $L$, $l_1 < l_2 < l_3$ and for all $\la I, J, K\ra$ and for all $\mu=(u_i, u_j, u_k)$ such that $u_i \in I, u_j \in J, u_k \in K$, $BT_{\ell}^{\mu}\in \bt$.
\end{definition}
      
\begin{figure}[h!]
\centering      
\inputtikz{bipartite_abt_a}
\caption[{[\acrshort{iebt}] Example Aggregated bitriangle}]{Aggregated bitriangle of the triple $(a,b,c)$ of \autoref{fig:bipartite-graph-example}. In this case as the \dref{def:abt} states, $\hat{U}_l$ does not contains disjoint sets, because we are using a compressing mechanism similar as described in \cite{Lai}. We can appreciate in the image that we can built an \acrshort{abt} with $b$ which has incidents edges in $1,5$. Note that not all of combinations are going to form a \acrshort{bt}.}
\label{fig:agg-bt-example}
\end{figure}
      
As we can see in \autoref{fig:agg-bt-example}, we have all the structures at our disposal to build a \acrshort{bt}. Now we are in condition to define a \acrshort{bt}.

\begin{definition}[\acrlong{bt}]\label{def:bt}
Let the triples $\mu=(u_1, u_2, u_3)$ and $\ell=(l_1, l_2,l_3)$ on $U$ and $L$, respectively, i.e.  $\{u_1, u_2, u_3\} \subseteq U$, $\{l_1, l_2,l_3\} \subseteq L$. 
The 6-cycle $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$  is a \textit{\acrfull{bt}} in $G$, denoted by $BT_{\ell}^{\mu} = \bti$. 
\end{definition}      

\begin{figure}[h!]
\begin{subfigure}[b]{0.5\textwidth}
\centering
\inputtikz{bipartite_bt_a}
\caption{\acrshort{bt} $(1,a,3,c,5,b,1)$}
\end{subfigure}
\begin{subfigure}[b]{0.5\textwidth}
\centering
\inputtikz{bipartite_bt_b}
\caption{\acrshort{bt} $(1,b,5,a,7,c,1)$}
\end{subfigure}
\caption[{[\acrshort{iebt}] Example of bitriangles}]{Bitriangles of the triple $(a,b,c)$ combined with vertices from $U$ $\{1,3,5,7\}$ of \autoref{fig:bipartite-graph-example}. In this case two bitriangles have been built from the \autoref{fig:agg-bt-example}}
\label{fig:bt-a-example}
\end{figure}

As we can see in \autoref{fig:bt-a-example}, the two possible \acrshort{bt} can be extracted from the \acrshort{abt} presented in \autoref{fig:agg-bt-example} are $(1,a,3,c,5,b,1)$ and $(1,b,5,a,7,c,1)$.

Because \acrshort{iebt} will allow to enumerate \acrshort{bt} using a \emph{pay-as-you-go} model, we need to allow the user to enumerate specific \acrshort{bt} according to some criteria.
In regards to that, we are going to define a Query Command that is going to be used in the pseudo-algorithm for that purpose.

\begin{definition}[\acrfull{qo}]\label{def:query:match} 
$Q$ is a \emph{\acrfull{qo}} is a value from the  \textit{sum type}
$\mathbb{P}(U + L) + \mathbb{P}(E)$ producing as a result a possible set of \acrshort{bt} that include any of the vertices or edges given in $Q$.
\end{definition}

Finally, we can elaborate a summary of all the definitions and terms in the \autoref{table:notation}.

\begin{table}[!ht]
\centering
\begin{tabular}{|c|l|} \hline
\textbf{Notation} & \textbf{Meaning}\\ \hline
$G=((U\cup L),E)$ & a bipartite graph\\  \hline
$n,m$ & the number of vertices and edges in $G$, resp.\\  \hline
$(u,l)$ & an edge between vertices $u$ and $l$\\  \hline
$(u_1,l,u_2)$ & a wedge with  middle vertex $l$\\  \hline
$\la l, W_l \ra$ & an \acrshort{awg}\\  \hline
$\aw$ & the set of all the possible \acrshort{awg} in $G$\\  \hline
$(u_1,l_1,u_2,l_2,u_3)$ & a \acrshort{dwg} with middle vertices $l_1$ and $l_2$\\  \hline 
$\la (l_1, l_2), U_l \ra$ & an \acrshort{adwg}\\  \hline
$\dw$ & the set of all the possible \acrshort{adwg} in $G$\\  \hline
$\dwi$ & Subset of $\dw$, such that $\dwi \subseteq \dw$ \\  \hline
$\la (l_1, l_2,l_3), \hat{U}_l \ra$ & an \acrshort{abt}\\  \hline
$\at$ & the set of all the possible \acrshort{abt} in $G$ \\  \hline
$\ati$ & Subset of $\at$, such that $\ati \subseteq \at$ \\  \hline 
$\bti$ & the \acrshort{bt} $u_1,l_1,u_2,l_3,u_3,l_2,u_1$\\  \hline
$\bt$ & the set of all the possible \acrshort{bt} in $G$ \\  \hline
$bt$ & Subset of $\bt$, such that $bt \subseteq \bt$ \\  \hline
\end{tabular}
\caption[{[\acrshort{iebt}] Summary of notations and their meanings}]{This table summarizes all the different object definitions that we have detailed in \autoref{sec:prem:def}. The first column describe the formal term used in the definitions on \autoref{sec:prem:def}. The second column summarize the meaning of each term}
\label{table:notation}
\end{table}
      
\section{Algorithm Sketch}\label{sub:sec:algo-sketch}
Dynamic Pipeline Algorithm for Enumerating Bitriangles ($\dpbt$) is defined in terms of the behavior of its four kinds stages: \textit{Source} ($\ibt$),  
\textit{Generator} ($\gbt$),  \textit{Sink} ($\obt$), and \textit{Filter}($\fbt$) stages. 
The algorithm considers a \acrlong{bt} as a convenient composition of three wedges as we can see the example in \autoref{fig:bitriangle-example}.
In order to reduce memory footprint, the algorithm aggregates results, i.e. the set of wedges having the same middle vertex is represented as a pair $\la l, W_l \ra$ where $l$ is the middle vertex and $W_l$ is the set of adjacent vertices of $l$ called \acrfull{awg} (see \dref{def:awg}).
The algorithm first collects \acrshort{awg} for every vertex in the $L$ set of the graph. Afterwards it constructs \acrfull{adwg} for every pair of distinct vertices, Finally  constructs \acrshort{abt}  for selected triples of vertices. 
The following \autoref{table:channels} describes the different channels that are connecting the stages in $\dpbt$.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{0.2\linewidth}|p{0.8\linewidth}|} \hline
\textbf{Channel} & \textbf{Meaning}\\ \hline
$C = \la IC, OC \ra$ & A Channel pair that connects input and output channel\\ \hline
$OC$ & Set of Output Channels \\ \hline
$C_E$ & Channel of $e \in E$ \\ \hline
$IC_E$ & Input Channels carrying $e \in E$ \\ \hline
$OC_E$ & Output Channels carrying $e \in E$ \\ \hline
$C_{W_l1}$ & Channel of \acrshort{awg} \\ \hline
$IC_{W_l1}$ & Input Channels carrying \acrshort{awg} \\ \hline
$OC_{W_l1}$ & Output Channels carrying \acrshort{awg} \\ \hline
$C_{W_l2}$ & Channel of \acrshort{awg} \\ \hline
$IC_{W_l2}$ & Input Channels carrying \acrshort{awg} \\ \hline
$OC_{W_l2}$ & Output Channels carrying \acrshort{awg} \\ \hline
$C_Q$ & Channel of \acrshort{qo} \\ \hline
$IC_Q$ & Input Channels carrying \acrshort{qo} \\ \hline
$OC_Q$ & Output Channels carrying \acrshort{qo} \\ \hline
$C_{BT}$ & Channel of $\bt$ \\ \hline
$IC_{BT}$ & Input Channels carrying $\bt$ \\ \hline
$OC_{BT}$ & Output Channels carrying $\bt$ \\ \hline
\end{tabular}
\caption[{[\acrshort{iebt}] Summary of Channels used in \acrshort{dpbt}}]{Summary of Channels used in \acrshort{dpbt}. The subindex on the Channel name indicates the element type this channel is carrying, either producing or consuming. Channels prefixed with $C$ are a generic form of denominating a channel independently of it is a producing or consuming. Channels prefixed with $IC$ are Input Channels or Consumers. Channels prefixed with $OC$ are Output Channels or Producers.}
\label{table:channels}
\end{table}

\begin{definition}[Filter State]
Let $\aw$ be a set of all possibles \acrlong{awg} in $G$.
Let $\dw$ be a set of all possibles \acrlong{adwg} in $G$.
Let $\at$ be a set of all possibles \acrlong{abt} in $G$.
An \textit{filter state} of \acrshort{dp} Filter with parameter $l$ has a sum type $\st = \la l, W_l \ra + \dwi + \ati$, such that $\la l, W_l \ra \in \aw, \dwi \subseteq \dw, \ati \subseteq \at$.
\end{definition}
 
\begin{figure}[h]
\centering  
\resizebox{1\textwidth}{!}{%
\inputtikz{btDP}
}
\caption[{[\acrshort{iebt}] $\dpbt$ Initial setup}]{Example of an initial setup of $\dpbt$. The text between dotted lines indicates the incoming data from an external source such as a file, socket, or any other. There are two incoming sources because one of them is carrying the edges and the other the commands \acrshort{qo}. Thick black double lines at the most right indicate the output targe that can be file, socket, screen, or any other. There is no data there because it is the initial step of \acrshort{dpbt}. At this initial step only $\ibt$, $\gbt$, and $\obt$ are set up with initial channels.}
\label{fig:btDP}
\end{figure}

\paragraph{Sketch} The setup of $\dpbt$ can be appreciated in \autoref{fig:btDP}. $\ibt$ reads from input stream all $(u,l) \in E$ and transfers to the following stage each $(u,l)$ using $C_E$.
For every $(u,l)$ that arrives to $\gbt$, a new $\fbt$ instance with parameter $l \in L$ is spawn. $\fbt$ contains four actors. 
First, $\aaa$ receives from $IC_E$ the edges and builds aggregated wedges, when there are no more edges it downstreams it to it's neighbour $\fbt$ using $OC_{W1}$. 
Then $\ab$ receives from $IC_{W1}$ aggregated wedges from previous $\fbt$, downstream to next $\fbt$ and $\gbt$ using $OC_{W1}$ and at the same time use its information to see 
if it can build an aggregated double wedge. If it can, it will store in its state $dw \in \dw$.
The need of bypassing all the aggregated wedges up to $\gbt$ is for retro feeding all the pipeline with all the aggregated wedges a second time, in order to find an \acrfull{awgc} as we defined in \dref{def:awgc}.
From retro feeding channel $IC_{W2}$, $\ac$ receives all the \acrshort{awg}  and builds \acrshort{abt} storing them in $\st$. 
$Q$ Commands are downstream from $\ibt$ to $\ad$ using channel $IC_Q$. $\ad$ receives all the commands, and for each of them, if there is match according to \dref{def:query:match}, it enumerates those \acrshort{bt} extracted from $\st$ and downstream to $\obt$ through $OC_{BT}$.

\section{Dynamic Pipeline for Enumerating Bitriangles}\label{sub:sec:iebt:dpalgo}
In this section, we present all the pseudo-code definitions of each of the stages described in ~\autoref{sub:sec:algo-sketch}. 
In spite of this work has been implemented using \acrshort{hs}, and in particular \acrshort{dpfh}, the pseudo-code algorithms presented here are language independent.
Before starting with the details, we introduce in \autoref{table:aux:fn} auxiliary functions that we use in the pseudo-code to help understanding better the desired behavior of the algorithm.

\begin{table}[!htp]
\centering
\begin{tabular}{|p{0.3\linewidth}|p{0.7\linewidth}|} \hline
\textbf{Function} & \textbf{Meaning}\\ \hline
$\sw(F,l,\st)$ & Spawn new filter instance with parameters $F$ (Filter template), $l \in L$ and $\st$ as the State of the Filter\\\hline
$\fd$ & Kill this filter instance because PostCondition is not satisfied\\ \hline
$\fid$ & State after calling $\fd$ on filter. Indicates if Filter is die or not. If it is dead, this filter instance does not participate anymore in the pipeline streaming processor\\ \hline
$\gs$ & Get Current State $\st$ for Filter Instance \\ \hline
$\us(\st)$ & Update Current State $\st$ for Filter Instance \\ \hline
$\p(\mathtt{v}, OC_x)$ & push some value $\mathtt{v}$ to some Output Channel $OC_x$ \\\hline
$\mt(Q, BT)$ & Check if a \acrshort{qo} $Q$ produces $\bt$ \\ \hline
\end{tabular}
\caption[{[\acrshort{iebt}] Summary of auxiliary functions for handling \acrshort{dpbt} internals}]{This table shows some auxiliary functions that are used to help understanding the pseudo-code general behavior. Depending on the language implementation chosen these functions might not exists at all, but we generalize here in order to describe a pseudo-code language-independent. For example in our \acrshort{hs} implementation there is not $\fd$ because functions in \acrshort{hs} clean after execution finish automatically by \acrshort{ghc}}
\label{table:aux:fn}
\end{table}
      
\begin{algorithm}[h!]
\SetKwInOut{P}{Input Data}
\SetKwInOut{Q}{Input Commands}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetAlgorithmName{}{src}{}
\SetAlgoRefName{[A1]}
\P{$IO_E$: File or Input Stream with Set of Edges $E$}
\Q{$IO_Q$: File or Input Stream with \acrlong{qo} $Q$}
\IC{$IC = \la IC_{W_l2} \ra$}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\ForAll(\tcp*[f]{Edges to Generator/Filter}){$(u,l) \in IO_E$}
{$\p((u,l), OC_E)$ \label{algo:source:1}
}
\ForAll(\tcp*[f]{Feedback from Generator to Filter}){$\la l, W_l \ra \in IC_{W_l2}$}
{$\p(\la l, W_l \ra, OC_{W_l2})$ \label{algo:source:2}
}
\ForAll(\tcp*[f]{Send Query Commands}){$Q \in IO_Q$}
{$\p(Q, OC_Q)$ \label{algo:source:3}
}
\caption[Source ($\ibt$)]{Source ($\ibt$): It process all the edges from the file or input channel $IO_E$ and send to the following stages. It also receives from $IC_{W_l2}$ all the feedback \acrshort{awg} that is sending back the $\gbt$. At the end it process also from other File or Input stream the Query Command $Q$ to be sent to th filters}
\label{algo:source}
\end{algorithm}

\paragraph{Source $\ibt$} In \autoref{algo:source} we can see in \autoref{algo:source:1} how the edges arriving from the input stream of the graph are downstream to the pipeline. 
Another important part as well is \autoref{algo:source:2}, the $\ibt$ is retro feed with \acrshort{awg} stream that is generated during pipeline execution.
This is important to finally build the \acrshort{bt} as we have describe in \autoref{sub:sec:algo-sketch}. Finally, \autoref{algo:source:3} shows how all the queries are downstream as well.

\begin{algorithm}[h!]
\SetKwInOut{P}{Filter Template}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetAlgorithmName{}{gen}{}
\SetAlgoRefName{[A2]}
\P{$F$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_{W_l2}, OC_{BT} \ra$}
\ForAll{$(u,l) \in IC_E$}
{$\sw(F, l, \la l, \{u\} \ra)$ \label{algo:gen:1}
}
\ForAll(\tcp*[f]{Feedback channel to retrofit Source}){$\la l, W_l \ra \in IC_{W_l1}$}
{$\p(\la l, W_l \ra, OC_{W_l2})$ \label{algo:gen:2}
}
\ForAll{$\bti \in IC_{BT}$}
{$\p(\bti, OC_{BT})$ \label{algo:gen:3}
}
\caption[Generator ($\gbt$)]{Generator ($\gbt$): For each edge $(u,l)$ it receives from previous stage, it spawn a new filter using $l$ as parameter of the Filter and $\{u\}$ as the state. It also receives all the \acrshort{awg} that previous filters built and sends back to $\ibt$. Finally it sends to the $\obt$ the \acrshort{bt} matched by filters according to Command Query $Q$}
\label{algo:gen}
\end{algorithm}

\begin{figure}[h]
\centering  
\resizebox{1\textwidth}{!}{%
\inputtikz{btDP_actor1}
}
\caption[{[\acrshort{iebt}] ]$\dpbt$ With Filter instances}]{This is the evolving state of the $\dpbt$ shows in \autoref{fig:btDP}. This image is showing what happen when a $\fbt$ is spawned. We can see how all the channels are set up in the middle of the spawned $\fbt$ and also between $\fbt$ and $\gbt$.}
\label{fig:btDP_actor1}
\end{figure}

\paragraph{Generator $\gbt$} $\gbt$ also have three main loops. In \autoref{algo:gen:1} it receives each edge $(u,l)$ not consumed by any already spawn  $\fbt$, and 
spawns a new $\fbt$ using $l \in L$ as filter parameter and initializing $\st = \la l, \{u\} \ra$ as it can be seen in \autoref{fig:btDP_actor1}. 
Spawn assumes that, the implementation will connect the channels to keep the downstream correct. Defines all the input channels of $\gbt$ as input channels of the newly spawn $\fbt$ and set $\fbt$'s output channels as $\gbt$ input channels.
In \autoref{algo:gen:2} we can see how the algorithm is receiving and retro feeding $\ibt$ with all the \acrshort{awg} produced by the $\fbt$ . This also assumes that $OC_{W2}$ in $\gbt$ 
is connected with $IC_{W2}$ in $\ibt$.
Finally, \autoref{algo:gen:3} sends all the results that $Q$ matches in the different filters to $\obt$.

\begin{algorithm}[h!]
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{O}{Output}
\SetAlgorithmName{}{sink}{}
\SetAlgoRefName{[A3]}
\O{$IO_{BT}$: File or Output Stream with $BT$}
\IC{$IC = \la IC_{BT} \ra$}
\ForAll(\tcp*[f]{Read Results and put in $IO_{BT}$}){$\bti \in IC_{BT}$}
{$put(\bti, IO_{BT})$
}
\caption[Sink ($\obt$)]{Sink ($\obt$): It receives \acrshort{bt} from $\gbt$ and send to the File or Output Stream}
\label{algo:sink}
\end{algorithm}

\paragraph{Sink $\obt$} In \autoref{algo:sink} shows a simple stage that receives all results and sends them to some output handler (file, standard output, etc.). 

\begin{algorithm}[h!]
\SetKwInOut{P}{Filter Template}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwFunction{actora}{actor1}
\SetKwFunction{actorb}{actor2}
\SetKwFunction{actorc}{actor3}
\SetKwFunction{actord}{actor4}
\SetKwFunction{filter}{filter}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fil}{}
\SetAlgoRefName{[A4]}
\P{$l \in L$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\df{\filter{}}{
      $\actora()$\\
      $\actorb()$\\
      $\actorc()$\\
      $\actord()$\\
}
\caption[Filter ($\fbt$)]{Filter ($\fbt$): Call sequentially to all the actors in this filter}
\label{algo:fil}
\end{algorithm}

\paragraph{Filter $\fbt$} In \autoref{algo:fil} we can see the simple call sequence over all the actor functions of the filter template. 

\begin{algorithm}[h!]
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{acta}{actor1}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa1}{}
\SetAlgoRefName{[A5]}
\P{$l \in L$}
\FS{$\la l, W_l \ra$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\PC{$|W_l| > 1 \lor \fid$}
\BlankLine
\df{\acta{}}{
$\la l, W_l \ra \leftarrow \gs$\\
\ForAll{$(u',l') \in IC_E$}
{\uIf{$l = l'$}{
      $W_l \leftarrow W_l \cup \{u'\}$\label{algo:act-1:1}
}\Else{$\p((u',l'),OC_E)$}
}
\uIf{$|W_l| > 1$}{
      $\us(\la l, W_l \ra)$\\ \label{algo:act-1:2}
      $\p(\la l, W_l \ra, OC_{W_l1})$\\
}\Else{$\fd$}
}
\caption[Actor1 ($actor_1$)]{Actor1 ($actor_1$): Build a set of aggregated wedges. This is, $W_l \subseteq U$ adjancents to $l$ Filter parameter. For each received edge $(u',l')$ which $l \neq l'$ by pass the edge to next filters. It updates the State of the filter with $W_l$ if it could build a $W_l$ with more than 1 vertex in $U$.}
\label{algo:act-1}
\end{algorithm}

\paragraph{Filter $\aaa$} 
$\aaa$ receives all edges not consumed by previous $\fbt$.
If the received edge $(u',l')$ is incident to l i.e. $l = l'$,  then $u'$ will be added to the list of \acrshort{awg}. Otherwise the edge is downstream to the next stage.
In \autoref{algo:act-1:2} the state is updated and \acrshort{awg} downstream, if and only if at least 1 wedge was collected. Otherwise, the filter is marked as dead using the  $\fd$ function.

\begin{algorithm}[h!]
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actb}{actor2}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa2}{}
\SetAlgoRefName{[A6]}
\P{$l \in L$}
\FS{$\la l, W_l \ra$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\BlankLine
\PrC{$W_l \subseteq U, |W_l| > 1$}
\PC{$|\dwi| \geq 1 \lor \fid$}
\df{\actb{}}{
$\la l, W_l \ra \leftarrow \gs$\\
\ForAll{$\la l', W_l' \ra \in IC_{W_l1}$}{
      \tcp*[h]{Send Wedge from previous filters to next one}
      $\p(\la l', W_l \ra, OC_{W_l1})$\\
      $\dwi \leftarrow \emptyset$\\
      \If{$W_l' \cap W_l \neq \emptyset$}{ \label{algo:act-2:1}
            $(l_l, l_u) \leftarrow (\argmin_{l,l'}, \argmax_{l,l'})$\\
            \uIf{$l < l'$}{
                  $(W_{l_l}, W_{l_u}) \leftarrow (W_l, W_l')$
            }\Else{
                  $(W_{l_l}, W_{l_u}) \leftarrow (W_l', W_l)$
            }
            $I \leftarrow W_{l_l} \setminus W_{l_u}$\\ \label{algo:act-2:2}
            $J \leftarrow W_{l_l} \cap W_{l_u}$\\
            $K \leftarrow W_{l_u} \setminus W_{l_l}$\\ \label{algo:act-2:3}
            $U_l \leftarrow \la I, J, K\ra$\\
            $\dwi \leftarrow dw \cup \{\la (l_l, l_u), U_l \ra\}$
      }
}
\uIf{$\dwi = \emptyset$}{$\fd$}
\Else{$\us(\dwi)$}
}
\caption[Actor2 ($actor_2$)]{Actor2 ($actor_2$): Receiving all aggregated wedges from previous filters, build a set of all possible aggregated double-wedges $\dwi = \{\la (l,l'), U_l \ra\}, \dwi \subseteq \dw$, which first component $l$ is smallest between the Parameter of the Filter and the vertices from the incoming wedges. At the end, it updates the State of the filter with $\dwi$ if $\dwi \neq \emptyset$}
\label{algo:act-2}
\end{algorithm}

\paragraph{Filter $\ab$} In \autoref{algo:act-2} \acrshort{adwg} is built. Following that idea and according to the \dref{def:adwg}, this algorithm will collect all the \acrshort{awg} 
from previous filters if an only if the condition in \autoref{algo:act-2:1} is met. Note that the two \acrshort{awg}, $W_l$ and $W_l'$ have different vertices from the set $L$. $W_l$ intersection check is mandatory since if \acrshort{awg} are disjoint, we cannot aggregate them.
After this checking from \autoref{algo:act-2:2} to \autoref{algo:act-2:3}, the algorithm builds three disjoint Sets to separate upper edges in three subsets; those which are incident only of 
$l$ and $l'$ which are $I$ and $K$ and those that are shared by both lower layer vertex. This can be appreciated in \autoref{fig:agg-double-wedge-example}.
Once \acrshort{adwg} is built $\st = \dwi$ updating the state for the next $\ac$.


\begin{algorithm}[h!]
\DontPrintSemicolon
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actc}{actor3}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa3}{}
\SetAlgoRefName{[A7]}
\P{$l \in L$}
\FS{$\dwi \subseteq \dw$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}  
\BlankLine
\PrC{$|\dwi| \geq 1$}
\PC{$|\ati| \geq 1 \lor \fid$}
\df{\actc{}}{
      $\dwi \leftarrow \gs$\\
      $\ati \leftarrow \emptyset$\\
      \ForAll{$\la l', W_l \ra \in IC_{W_l2}$}{
            \tcp*[h]{By pass to be used by following Filters}
            $\p(\la l', W_l \ra, OC_{W_l2})$\\ 
            \tcp*[h]{For each double wedge in State}\\
            \ForEach{$\la (l_l, l_u), \la I, J, K \ra \ra \in \dwi, l_l < l' \land l_u > l'$}{
                  $I' \leftarrow I \cup J$\\
                  $K' \leftarrow K \cup J$\\
                  \If{$W_l \cap I' \neq \emptyset \land W_l \cap K' \neq \emptyset$}{
                        $I' \leftarrow I' \cap W_l$\\
                        $K' \leftarrow K' \cap W_l$\\
                        $\hat{U}_l  \leftarrow \la I', J, K' \ra$\\
                        $\ati \leftarrow \ati \cup \big\{\la (l_l, l', l_u), \hat{U}_l \ra\big\}$
                  }
            }
      }
      \uIf{$\ati = \emptyset$}{$\fd$}
      \Else{$\us(\ati)$\\}
}
\caption[Actor3 ($actor_3$)]{Actor3 ($actor_3$): Receiving all aggregated wedges that came from feedback channel, build a Set of all possible Aggregated bi-triangles $\ati = \{\la (l_l, l_m, l_u), U_l \ra\}, \ati \subseteq \at$, , such that $l = l_l \lor l = l_u$, where $l$ is the Filter Parameter and $l_m$ is the middle vertex of the incoming wedge. At the end, it updates the State of the filter with $\ati$ if $\ati \neq \emptyset$}
\label{algo:act-3}
\end{algorithm}

\paragraph{Filter $\ac$} $\ac$ focuses on treating elements from feedback channel $IC_{W2}$ which is going to downstream all the \acrshort{awg} of all filters.
This is because in order to build \acrshort{abt} finding all the possibles \acrshort{awgc}. This is what is doing \autoref{algo:act-3} according to definition 
\dref{def:awgc} and \dref{def:abt}. If that can be achieved, algorithm sets $\st = \ati$ and $\ad$ can be executed.

\begin{algorithm}[h!]
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actc}{actor4}
\SetKwFunction{butV}{buildBtVertex}
\SetKwFunction{butE}{buildBtEdge}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa4}{}
\SetAlgoRefName{[A8]}
\P{$l \in L$}
\FS{$\ati \subseteq \at$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}  
\BlankLine
\PrC{$|\ati| \geq 1$}
\df{\actc{}}{
$\ati \leftarrow \gs$\\
\ForAll{$Q \in IC_Q$}{
      \ForEach{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati$}{
            \Switch{$Q$}{
                  \Case{$\mathbb{P}(U + L)$}{
                        \If{$\mathbb{P}(U + L) \cap \{l_l, l_m, l_u\} \neq \emptyset \lor \mathbb{P}(U + L) \cap (I \cup J \cup K) \neq \emptyset$}{
                              $\btii \leftarrow \butV(\la (l_l, l_m, l_u), \la I,J,K \ra \ra), \mathbb{P}(U + L))$\\
                              \ForAll{$\bti \in \btii$}{
                                    $\p(\bti, OC_{BT})$
                              }
                        }
                  }
                  \Case{$\mathbb{P}(E)$}{
                        \ForEach{$(u,l) \in \mathbb{P}(E)$}{
                              \If{$(l = l_l \lor l = l_m \lor l = l_u) \land u \in (I \cup J \cup K)$}{
                                    $\btii \leftarrow \butE(\la (l_l, l_m, l_u), \la I,J,K \ra \ra), (u,l))$\\
                                    \ForAll{$\bti \in \btii$}{
                                          $\p(\bti, OC_{BT})$
                                    }
                              }
                        }
                  }
            }
      }
}
}
\caption[Actor4 ($actor_4$)]{Actor4 ($actor_4$): Receiving all the Query Commands $Q$ that arrives through Channel $IC_Q$, verify if matches with some Bi-triangles that in the state $\ati \subseteq at$ of this Filter. If some bi-triangle matches it will be downstream to the Channel $OC_{BT}$ to be processed by the Sink}

\label{algo:act-4}
\end{algorithm}

\paragraph{Filter $\ad$} Once the execution reaches $\ad$, it is ready for processing $Q$ \acrlong{qo}. 
Since we have a compress representation of \acrshort{bt}, which is a similar idea exposed here~\cite{Lai}, we need to enumerate incrementally all the \acrshort{bt} present in the compressed format and filter the ones that match the command.
The matches proceeds in the following manner. Given a \acrshort{abt} with the form $\la \ell, \hat{U}_l \ra$, such that $\ell = (l_1,l_2,l_3)$ and $\hat{U}_l = \la I,J,K \ra$, where $I \subseteq U, J \subseteq U, K \subseteq U$, if the \acrshort{qo} contains a command with vertices, those vertices are search in $\ell$ and $\hat{U}_l$. 
There are two posibilities. On the first case, if any of those vertices that belongs to $Q$ matches $\ell$, then forall $u_i \in I, u_j \in J, u_k \in K$ where $ u_i \neq u_j \neq u_k$, a \acrshort{bt} is built using a 6-cycle $(u_i, l_1, u_j, l_3, u_k, l_2, u_i)$ path.
On the second case, if any of those vertices that belongs to $Q$ matches on some vertex in $\hat{U}_l$, build only the \acrshort{bt} in which 6-cycle $(u_i, l_1, u_j, l_3, u_k, l_2, u_i)$ path contains that vertex in $Q$.
Using the same construction process a \acrshort{bt} is built if \acrshort{qo} contains a command with edges and any of those edges matches with any of the possible \acrshort{bt} 6-cycle path.

The following pseudo-code definitions on \autoref{algo:buildBtVertex} and \autoref{algo:buildBtEdge} are auxiliary functions that are called
from $\ad$ if $Q$ pattern match either with $\mathbb{P}(U + L)$ or $\mathbb{P}(E)$.

\begin{algorithm}[h!]
\SetKwInOut{I}{Input}
\SetKwInOut{O}{Output}
\SetKwFunction{but}{buildBtVertex}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{a1}{}
\SetAlgoRefName{[A9]}
\I{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati, \ati \subseteq \at$}
\I{$\mathbb{P}(U + L)$}
\O{$\btii \subseteq \bt$ or $\emptyset$ if cannot build any $\btii$}
\df{\but{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, $\mathbb{P}(U + L)$}}{
      $\btii \leftarrow \emptyset$\\
      \uIf{$\mathbb{P}(U + L) \cap \{l_l, l_m, l_u\}$}{
            \tcp*[h]{If it is in lower i need to build all for this lower triplet}\\
            \ForEach{$i \in I$}{
                  \ForEach{$j \in J, j \neq i$}{
                        \ForEach{$k \in K, k \neq i \land k \neq j$}{
                              $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                        }
                  }
            }
      }\Else{
            \tcp*[h]{Otherwise just build those that are in the this upper $v$}\\
            \ForEach{$i \in I$}{
                  \ForEach{$j \in J, j \neq i$}{
                        \ForEach{$k \in K, k \neq i \land k \neq j \land (\mathbb{P}(U + L) \cap \{i,j,k\} \neq \emptyset$}{
                              $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                        }
                  }
            }
      }
      \Return{$\btii$}
}
\caption[Function \mintinline{shell}{buildBtVertex}]{Function \mintinline{shell}{buildBtVertex}: Given a Set of Vertex in $\mathbb{P}(U + L)$, if any of those vertices matches with some vertex in the parameter of the function $\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, build the set of bi-triangles that matches that query}
\label{algo:buildBtVertex}
\end{algorithm}

\begin{algorithm}[h!]
\SetKwInOut{I}{Input}
\SetKwInOut{O}{Output}
\SetKwFunction{but}{buildBtEdge}
\SetKwFunction{he}{hasEdge}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{a2}{}
\SetAlgoRefName{[A10]}
\I{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati, \ati \subseteq \at$}
\I{$(u,l)$}
\O{$\btii \subseteq \bt$ or $\emptyset$ if cannot build any $\btii$}
\df{\but{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, $\mathbb{P}(U + L)$}}{
      $\btii \leftarrow \emptyset$\\
      \ForEach{$i \in I$}{
            \ForEach{$j \in J, j \neq i$}{
                  \ForEach{$k \in K, k \neq i \land k \neq j \land \he((u,l), (l_l,l_m,l_u),(i,j,k))$}{
                        $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                  }
            }
      }
      \Return{$\btii$}
}
\df{\he{$(u,l), (l_l,l_m,l_u), (i,j,k)$}}{
      \If{$(u,l) = (l_l, i) \lor (u,l) = (l_l, j) \lor (u,l) = (l_u, j) \lor (u,l) = (l_u, k) \lor (u,l) = (l_m, i) \lor (u,l) = (l_m, k)$}{
            \Return{True}
      }\Else{
            \Return{False}
      }
}
\caption[Function \mintinline{shell}{buildBtEdge}]{Function \mintinline{shell}{buildBtEdge}: Given a Set of Edges in $\mathbb{P}(E)$, if any of those edges matches with some edge in the parameter of the function $\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, build the set of bi-triangles that matches that query}
\label{algo:buildBtEdge}
\end{algorithm}

% \clearpage
% \section{DRAFT - Complexity Analysis of Algorithm}
% The complexity analysis provided in this section will cover each of the principal pseudo-code algorithms described in the previous \autoref{sub:sec:iebt:dpalgo}, this is \autoref{algo:source}, \autoref{algo:gen}, \autoref{algo:sink} and \autoref{algo:fil} (including all actors). 

% \begin{theorem}[$|\aw| \leq |L|$]\label{theorem:awg}
% The size of all possible aggregated wedges is upper bound by $|L|$.
% \end{theorem}
% \begin{proof}[Anlaysis]
% This can be deduced by \dref{def:awg}, because at most each $l \in L$ is participating on a wedge.
% \end{proof}

% \begin{theorem}[$|\dw| \leq \binom{|L|}{2}$]\label{theorem:adwg}
% The size of all possible aggregated double-wedges is upper bound by $\binom{|L|}{2}$.
% \end{theorem}
% \begin{proof}[Anlaysis]
% This can be deduced by \dref{def:adwg}, and by \autoref{theorem:awg}. If we can combine vertices from $L$ taken by $2$ without repetition that forms an \acrshort{adwg}, we have at most that amount of possible aggregated double-wedges combinations.
% \end{proof}
      
% \begin{complexity}[Source $\ibt$]\label{prop:comp-src}
% The total complexity of $\ibt$ algorithm in worst-case is $O(|E|)$.
% \end{complexity}
% \begin{proof}[Anlaysis]
% In the case of this stage, we have three \texttt{for} loops. The first one is done in the number of edges of the graph $|E|$. The second \texttt{for} loop iterates over  
% all possible \acrshort{awg} which is at most $|L|$ according to \autoref{theorem:awg}.
% And the last \texttt{for} loop is taking the size of all commands $Q$ provided by the user. Then, worst-case complexity is $O(|E| + |L| + |Q|)$.
% Since $|L| \leq |E|$ by \dref{def:bt} and $|Q| << |E|$ because otherwise the user will be able to manually inspect the whole graph. Since the algorithm implements a \emph{pay-as-you-go} model
% as we have described in \autoref{relate-work}, it has a high cost for the user to ask for an amount of commands near to $|E|$.
% Therefore, the dominant term is $|E|$, and the complexity of this part of the algorithm is $O(|E|)$.
% \end{proof}

% \begin{complexity}[Generator $\gbt$]\label{comp:anal:gen}
% The total complexity of $\gbt$ algorithm in worst-case is $O(2|L| + |Q||\ati|)$.
% \end{complexity}
% \begin{proof}[Anlaysis]
% $\gbt$ receives at most $|L|$ edges in in \autoref{algo:gen:1} first loop, since $\aaa$ will collect all the upper vertices from the same $l$ without bypassing those collected edges (\autoref{theorem:awg}).
% In \autoref{algo:gen:2}, the second loop, it will receive at most $|L|$ aggregated wedges $W_l$, which also can be deduced by \autoref{theorem:awg}.
% Finally, it will receive all matched $\btii \subseteq \bt$. By \autoref{algo:act-4}, \autoref{algo:buildBtEdge} and \autoref{algo:buildBtVertex} the amount of possible $\btii$ matched is $|Q| \times |\ati|$ (see \dref{def:abt}).
% Then worst-case complexity is $O(|L| + |L| + |Q||\ati|) = O(2|L| + |Q||\ati|)$.
% \end{proof}

% \begin{complexity}[Sink $\obt$]
% The total complexity of $\obt$ algorithm in worst-case is $O(|Q||\ati|)$.
% \end{complexity}
% \begin{proof}[Anlaysis]
% Obvious by definition of \autoref{algo:sink} and by complexity analysis in \autoref{comp:anal:gen}.
% \end{proof}

% \paragraph{Filter Consideration}\label{comp:an:filter:note} In the case of complexity analysis of the Filter instances $\fbt$ algorithms, which involves the four actors, we are going to take into consideration the worst-case.
% The worst-case is the first filter, because it is the one that is going to receive all the edges from the $\ibt$ at least as we can see in \autoref{sub:sec:algo-sketch}. 
% If the second filter is spawned, is going to receive at most $|E|-2$ edges, the third $|E|-3$, and so on. 

% \begin{complexity}[Filter $\fbt$]
% The total complexity of $\fbt$ algorithm in worst-case is $O(|E| + |L| \times \binom{|L|}{2} \times 6|U| + |Q||\ati|)$.
% \end{complexity}
% \begin{proof}[Anlaysis]
% Since actors in filters are executed sequentially, lets analyze each actor separately. 
% The complexity of $\aaa$ is $O(|E|)$ by \dref{algo:act-1}. 
% This worst-case complexity of $|E|$ for $\aaa$ only happens in the first filter as we have explained before in \ref{comp:an:filter:note}. 
% Then for $\ab$ complexity is $O(|L| \times 6|U|)$. $|L|$ is the upper bound by \autoref{theorem:awg} since the \texttt{for} loop is iterating over all $W_l$ received from the channel.
% Inside that \texttt{for} loop there 3 sets operations are taking place. Each of those operations are upper bounded by $|U|$ in the worst-case, since $W_l \subseteq U$ by \dref{def:awg}. 
% Then, the cost of each loop is $O(6|U|)$ worst-case.  
% The complexity of $\ac$ is $O(|L| \times \binom{|L|}{2} \times 6|U|)$. The first $|L|$ is the outer \texttt{for} loop which receives all the possible \acrshort{awg}, which is upper bounded by $|L|$ according to \autoref{theorem:awg}.
% $\binom{|L|}{2}$ is the second \texttt{for} loop which is iterating over all the \acrshort{adwg} that are in this filter, and it is upper bounded by $\binom{|L|}{2}$ according to \autoref{theorem:adwg} and supposing that this filter contains all the \acrshort{adwg} in the worst case. 
% Then, $6|U|$ is inside of the second \texttt{for} loop and follows the same analisys for the set operations provided in $\ab$. Finally, $\ad$ takes $O(|Q||\ati|)$ as we have described in $\gbt$ complexity analysis.
% Gluing everything together the worst-case complexity of four actors in the filter instance is $O(|E| + |L| \times 6|U| + |L| \times \binom{|L|}{2} \times 6|U| + |Q||\ati|)$. 
% Since $|L| \times \binom{|L|}{2} \times 6|U| > |L| \times 6|U|$, we can eliminate that term which is not dominating. Therefore $O(|E| + |L| \times \binom{|L|}{2} \times 6|U| + |Q||\ati|)$.

% \end{proof}
      
      
\clearpage
\section{Correctness of the Algorithm}
Given a bitriangle  $BT_{\ell}^{\mu} = \bti$ as we defined in \dref{def:bt}, where the 6-cycle is $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$.

%A bitriangle can be described as a sequence $(C,a,A,b,B,c,C)$  where $\{ a,b,c\} \in L$  and $\{ A,B,C\} \in U\footnote{In the enumeration, L and $U$ be interchanged}$

We need to prove that the algorithm can enumerate all bitriangle in the graph and also that there are no duplicates in the enumeration.

Very recently, Qiao et al. proposed CrystalJoin~\cite{Lai} that aims at resolving the output crisis by compressing the intermediate results.
We use the same technique, compressing a group of bitriangles as we define in \dref{def:abt} $\langle \ell, \hat{U}_l\rangle$, where $\ell = (l_1,l_2,l_3,)$ and $\hat{U}_l= \la I, J, K\ra$, such that $I \subseteq U, J \subseteq U, K \subseteq U$.
 

First we are going to prove that if we take all the triples $(l_1,l_2,l_3)$  such $l_1<l_2$ and $l_2<l_3$  and  $\bti$ is a  bitriangle, then it is not stored twice (theorem \ref{TH-unicity}). 
We will show that we store all the aggregate bitriangles where $u_1,u_2,u_3$  are distinct and $u_1$ is incident to $l_1$ and $l_2$, $u_2$ is incident to $l_1$ and $l_3$ and $u_3$ is incident to $l_2$ and $l_3$ (theorem \ref{TH-all}). 
\begin{theorem} \label{TH-unicity} Given a graph a bipartite graph $G = ((U\cup L),E)$ and the \acrshort{iebt} every bitriangle occurring in $G$ is stored at most once.

\end{theorem}
\begin{proof}

Let $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$, such that $l_1 < l_2 <l_3$. For every feasible permutation  starting with a node in $U$ we are going to proof that only one will be accepted by $\ab$, or $\ac$.  
\begin{itemize}
      \item According to lines 7-12 of $\ab$ $(u_1,l_2,u_3,l_3,u_2,l_1,u_1)$ is  not accepted  when constructing elements of $\dw$ to be used by $\ac$  because $l_2 > l_1$ 
      \item According to lines 7 of $\ac$ $(u_3,l_2,u_1,l_1,u_2,l_3,u_3)$ is not accepted because $l_2 > l_1$
      \item According to lines 7-12 of $\ab$ $(u_3,l_3,u_2,l_1,u_1,l_2,u_3)$ is  not accepted  when constructing elements of $\dw$ to be used by $\ac$  because  $l_3 > l_2$
      \item According to lines 7-12 of $\ab$ $(u_2,l_3,u_3,l_2,u_1,l_1,u_2)$ not accepted because $l_3 > l_1 $
      \item  According to lines 7-12 of $\ab$ and line 7 in $\ac$ $(u_2,l_1,u_1,l_2,u_3,l_3,u_2)$ is accepted because $l_1 < l_3 $ and $l_1 < l_2 <l_3$ 
      \item According to  line 7 in $\ac$ $(u_1, l_1,u_2,l_3,u_3,l_2,u_1)$ is not accepted because $l_3 > l_2$
\end{itemize}


Therefore the  only bitriangle  constructed by the algorithm is the one that satisfies $l_1 < l_2 < l_3$ where $u_1,u_2,u_3$  are distinct and $u_1$ is incident to $l_1$ and $l_2$, $u_2$ is incident to $l_1$ and $l_3$ and $u_3$ is incident to $l_2$ and $u_3$.
\end{proof}


\begin{theorem}\label{TH-all}Given a bipartite graph $G$, if the bitriangle $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$ such that $l_1 < l_2 <l_3$ is present in G, then $\bti$ can be enumerated.
\end{theorem}


\begin{proof}
\iffalse
Obvious from the definition of $I,J,K$  and the algorithm of obtaining bitriangles. 
\fi
  Let $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$, such that $l_1 < l_2 <l_3$ is present in the graph. 

When $\aaa$ acting in filter $F_{l_1}$ ends reading all the edges, $\{u_1,u_2\} \subseteq W_{l_1}$. Also when $\aaa$ in filter $F_{l_3}$ ends reading all the edges, $\{u_2,u_3\} \subseteq W_{l_3}$. 

As $l_1 < l_3$ in $\ab$, in lines 7-12, in filter $F_{l_1}$ or in filter $F_{l_3}$, the pair $(l_1,l_3)$  will be added to 
$\mathsf{dw}$. When $\ac$ in lines 7-16, in filter $F_{l_1}$ or in filter $F_{l_3}$ receives $(l_2, W_{l_2})$  will construct the corresponding  $BT$ because of the condition in line 10 is satisfied (non empty intersection). Therefore, the bitriangle is stored in $\mathsf{bt}$ an thus $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$ can be listed by $\ad$.
\end{proof}
\iffalse
So we are going to talk from now on about the bitriangles stored in filter $F_a$.

At the end of the execution of $\ac$ $F_a$ constructs the sets where to choose $A,B,C$ $\at$

Actor 1 collects in $F_a$ all the nodes in $U$ adjacent to $a$ i.e. all the candidates to choose $A$. Afterward this set will be reduced. 

Actor 2 receives pairs $(c,V)$ where $V$ are all the nodes adjacent to $c$ in order to test the possibility of constructing a new double wedge.  If the conditions are fulfilled, it adds the double wedge $\la (a,c), U_{t_1} \ra$,  or $\la (c, a), U_{t_2} \ra$. 

In each filter, the pair of lower vertices in the double edges are pairs constructed by $a$ and vertices that are parameters of filters that are before the filter $F_a$. Therefore, the double edges recorded are present in at most one filter.

Actor 3 receives pairs $(b,M) $ where $M$ are all the nodes adjacent to $b$ and has in memory a set of double wedges $\la (a,c), l_2), U_{t_1} \ra$

$\ac$ accepts b as a candidate to construct an element of the set of aggregate bitriangles if $a < b < c$. Therefore the aggregated bitriangles so constructed are recorded in a single filter due to the fact that that the pair $(a,c)$ is present in a single filter.
\fi

        
 
\section{\acrshort{dpbt} implementation}\label{sec:iebt:hs:imp}
As we have seen in the previous \autoref{dp-hs}, first we need to define the \acrshort{dp} using the \acrshort{dsl}.

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={3}]{haskell}

type DPBT = Source (Channel (Edge :<+> W :<+> Q :<+> BT :<+> BTResult :<+> W :<+> Eof))
      :=> Generator (Channel (Edge :<+> W :<+> Q :<+> BT :<+> BTResult :<+> Eof))
      :=> FeedbackChannel (W :<+> Eof)
      :=> Sink

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] Enconding of \acrshort{dpbt}}
\label{src:dpbt:1}
\end{listing}

In \autoref{src:dpbt:1} can be appreciated the use of feedback channel in the highlighted line. 
Automatically \acrshort{dpbt} is going to connect this with the $\ibt$.

$\ibt, \obt, \gbt$ are not going to be covered because they are straightforward to follow from the code. 
The most sofisticated part of the algorithm, as we have seen in \autoref{sub:sec:iebt:dpalgo}, relies on actor filter.

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={16,21}]{haskell}

actor1 :: Edge
      -> ReadChannel (UpperVertex, LowerVertex)
      -> ReadChannel W
      -> ReadChannel Q
      -> ReadChannel BT
      -> ReadChannel BTResult
      -> ReadChannel W
      -> WriteChannel (UpperVertex, LowerVertex)
      -> WriteChannel W
      -> WriteChannel Q
      -> WriteChannel BT
      -> WriteChannel BTResult
      -> WriteChannel W
      -> StateT FilterState (DP st) ()
actor1 (_, l) redges _ _ _ _ _ we ww1 _ _ _ _ = do
 foldM_ redges $ \e@(u', l') -> do
   e `seq` if l' == l then modify $ flip modifyWState u' else push e we
 finish we
 state' <- get
 case state' of
   Adj w@(W _ ws) -> when (IS.size ws > 1) $ push w ww1
   _              -> pure ()

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\aaa$}
\label{src:dpbt:2}
\end{listing}

In \autoref{src:dpbt:2} $\aaa$ source code can be appreciated. Since all the actors are inside the same filter context, all of them have access to read and write
channels of all the filters. That explains the number of parameters which is generated by the \acrshort{idl}.
The first highlighted line is the catamorphism (\mintinline{haskell}{foldM_}) of the $IC_E$ channel, which corresponds to \autoref{algo:act-1:1}.
At the last highlighted line the code is downstream the aggregated wedge collected in this filter.

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={22,30,36}]{haskell}

actor2 :: Edge
      -> ReadChannel (UpperVertex, LowerVertex)
      -> ReadChannel W
      -> ReadChannel Q
      -> ReadChannel BT
      -> ReadChannel BTResult
      -> ReadChannel W
      -> WriteChannel (UpperVertex, LowerVertex)
      -> WriteChannel W
      -> WriteChannel Q
      -> WriteChannel BT
      -> WriteChannel BTResult
      -> WriteChannel W
      -> StateT FilterState (DP st) ()
actor2 (_, l) _ rw1 _ _ _ _ _ ww1 _ _ _ _ = do
 state' <- get
 case state' of
   Adj (W _ w_t) -> do
     modify $ const $ DoubleWedges mempty
     foldM_ rw1 $ \w@(W l' w_t') -> do
       push w ww1
       buildDW w_t w_t' l l'
     finish ww1
   _ -> pure ()

buildDW :: IntSet -> IntSet -> LowerVertex -> LowerVertex -> StateT FilterState (DP st) ()
buildDW w_t w_t' l l' =
let pair       = Pair (min l l') (max l l')
      paramBuild = if l < l' then (w_t, w_t') else (w_t', w_t)
      ut         = uncurry buildDW' paramBuild
in  if (IS.size w_t > 1) && l /= l' && not (IS.null (IS.intersection w_t w_t')) && not (nullUT ut)
      then modify $ flip modifyDWState (DW pair ut)
      else pure ()

buildDW' :: IntSet -> IntSet -> UT
buildDW' !w_t !w_t' = (w_t IS.\\ w_t', IS.intersection w_t w_t', w_t' IS.\\ w_t)

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ab$}
\label{src:dpbt:3}
\end{listing}

In \autoref{src:dpbt:3}, the interesting part of $\ab$ is the construction of $\dwi$. That is done by the function \mintinline{haskell}{buildDW}
and \mintinline{haskell}{buildDW'} which are building the three subsets required to create aggregated double-wedges $\dwi$.

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={27,34-40}]{haskell}      
actor3 :: Edge
       -> ReadChannel (UpperVertex, LowerVertex)
       -> ReadChannel W
       -> ReadChannel Q
       -> ReadChannel BT
       -> ReadChannel BTResult
       -> ReadChannel W
       -> WriteChannel (UpperVertex, LowerVertex)
       -> WriteChannel W
       -> WriteChannel Q
       -> WriteChannel BT
       -> WriteChannel BTResult
       -> WriteChannel W
       -> StateT FilterState (DP st) ()
actor3 (_, l) _ _ _ _ _ rfb _ _ _ _ _ wfb = do
  state' <- get
  case state' of
    DoubleWedges dwtt -> do
      modify $ const $ BiTriangles mempty
      foldM_ rfb $ \w@(W l' w_t') -> do
        push w wfb
        when (hasDW dwtt) $ do
          let (DWTT dtlist) = dwtt
          forM_ dtlist $ \(DW (Pair l_l l_u) ut) ->
            let triple = Triplet l_l l' l_u
                result =
                  if l' < l_u && l' > l_l then filterUt w_t' ut else Nothing
            in  maybe (pure ()) (modify . flip modifyBTState . BT triple) result
      finish wfb
    _ -> pure ()

filterUt :: IntSet -> UT -> Maybe UT
filterUt wt (si, sj, sk) =
  let si' = IS.filter (`IS.member` wt) si 
      sj' = IS.filter (`IS.member` wt) sj
      sk' = IS.filter (`IS.member` wt) sk
      sij' = si' `IS.union` sj'
      sjk' = sk' `IS.union` sj'
      wtInSome = not (IS.null sij' || IS.null sjk')
  in  if wtInSome then Just (sij', sj, sjk') else Nothing
\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ac$}
\label{src:dpbt:4}
\end{listing}

$\ac$ in \autoref{src:dpbt:4}, shows the process of collecting aggregated bi-triangles $\ati$. In highlighted lines on \autoref{src:dpbt:4} we can see the algorithm to detect when the \acrshort{awg}
received in the feedback channel are \acrshort{awgc} according to \dref{def:awgc}.

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={21-22,27-31}]{haskell}            
actor4 :: Edge
       -> ReadChannel (UpperVertex, LowerVertex)
       -> ReadChannel W
       -> ReadChannel Q
       -> ReadChannel BT
       -> ReadChannel BTResult
       -> ReadChannel W
       -> WriteChannel (UpperVertex, LowerVertex)
       -> WriteChannel W
       -> WriteChannel Q
       -> WriteChannel BT
       -> WriteChannel BTResult
       -> WriteChannel W
       -> StateT FilterState (DP st) ()
actor4 (_, l) _ _ query _ rbtr _ _ _ wq _ wbtr _ = do
  state' <- get
  case state' of
    BiTriangles bttt -> do
      rbtr |=> wbtr
      foldM_ query $ \e -> do
        push e wq
        unless (hasNotBT bttt) $ sendBts bttt e wbtr
    _ -> pure ()

sendBts :: MonadIO m => BTTT -> Q -> WriteChannel BTResult -> m ()
sendBts (BTTT bttt) q@(Q c _ _) wbtr = case c of
  ByVertex vx    -> forM_ bttt (\bt -> filterBTByVertex bt vx (flip push wbtr . RBT q))
  ByEdge   edges -> forM_ bttt (\bt -> filterBTByEdge bt edges (flip push wbtr . RBT q))
  AllBT          -> forM_ bttt (R.mapM_ (flip push wbtr . RBT q) . buildBT)
  Count          -> forM_ bttt (flip push wbtr . RC q . R.length . buildBT)
  _              -> pure ()
\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ad$}
\label{src:dpbt:5}
\end{listing}

$\ad$ in \autoref{src:dpbt:5} shows the pattern match done over the query $Q$ sum type and the construction
of the final \acrshort{bt} to be downstream to the $\obt$. 

\begin{listing}[htp!]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={}]{haskell}            
filterBTByVertex :: MonadIO m => BT -> IntSet -> ((Int, Int, Int, Int, Int, Int, Int) -> IO ()) -> m ()
filterBTByVertex bt vertices f =
  if inLower bt vertices then
     liftIO
     . mapConcurrently_ f
     . buildBT
     $ bt
  else 
    if inUpper bt vertices 
      then buildBT' bt vertices f
      else pure ()

filterBTByEdge :: MonadIO m => BT -> Set Edge -> ((Int, Int, Int, Int, Int, Int, Int) -> IO ()) -> m ()
filterBTByEdge bt edges f =
  when (getAny $ foldMap (`hasEdge` bt) edges)
   $ liftIO . mapConcurrently_ f . R.filter (isInSetEdge edges) . buildBT $ bt
      
\end{minted}
\caption{[\mintinline{shell}{Edges.hs}] \texttt{filterBTByVertex} and \texttt{filterBTByEdge}}
\label{src:dpbt:6}
\end{listing}
      
Finally, definition of \mintinline{haskell}{filterBTByEdge} and \mintinline{haskell}{filterBTByVertex} can be seen in \autoref{src:dpbt:6} and differs 
from the pseudo-code presented in \autoref{algo:buildBtEdge} and \autoref{algo:buildBtVertex} because it is using \acrshort{hs} specific combinators and 
for-comprehension lists to take advantage of the non-strictness of the language as well as some concurrency primitives.

\section{Chapter Summary}
This chapter presents the details of the \acrshort{dpbt} algorithm. In the first part, we have introduced the sketch of the algorithm.
Then, we have described each of the pseudo-code definitions of each component: $\ibt, \gbt, \fbt, \obt$ and actors. 
After that, we have presented a correctness proof of the pseudo-code algorithm.
At the end of the chapter, we have shown how we implemented this using \acrshort{dpfh} is described in \autoref{dp-hs}.

