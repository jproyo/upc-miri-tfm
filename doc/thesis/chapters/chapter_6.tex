\chapter{An algorithm for incrementally enumerating Bi-Triangles using DP}\label{incr-algo-bt-dp}
In this chapter, we first describe the overall idea of the algorithm for incrementally enumerate 
\acrshort{bt}. After that, we present the algorithms in pseudo-code format and then a complexity analysis of the principal functions of the algorithm.
Athe the end, we provide the proof of correctness and the implementation using the \acrshort{dpfh}.  

\section{Preliminaries Definitions}
In order to understand how the algorithm works, we need to provide some basic definitions that are already exposed in previous work~\cite{btcount}, and
at the same time, we define other structures that we use for giving a solution to the problem.
Let's enumerate all those definitions in the following paragraphs.

\begin{definition}[\acrlong{bg}] 
A bipartite graph is an undirected graph $G=(V,E)$  such that $V=(U\cup L)$, $U\cap L=\emptyset$ and $E\subseteq U\times L$.\cite{Bondy1976}
\end{definition}

Additionally, without loss of generality, we assume that  $U\subseteq \mathbb{N}$ and $L\subseteq \mathbb{N}$. Consequently, $(U,<)$  and $(L,<)$ are strict total orders. We can see an example of a \acrshort{bg}
in \autoref{fig:bipartite-graph-example}.

\begin{definition}[\acrlong{bt}]\label{def:bt}
Let $G=((U\cup L),E)$ be a bipartite graph. Let the triples $\mu=(u_1, u_2, u_3)$ and $\ell=(l_1, l_2,l_3)$ on $U$ and $L$, respectively, i.e.  $\{u_1, u_2, u_3\} \subseteq U$, $\{l_1, l_2,l_3\} \subseteq L$. 
The 6-cycle $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$  is a \textit{bi-triangle} in $G$, denoted by $BT_{\ell}^{\mu} = \bti$. 
\end{definition}      

\begin{definition}[\acrfull{wg}]
Let $G=((U\cup L),E)$ be a bipartite graph. A  \textit{wedge} in $G$ is a triple $(u_1,l,u_2), \{u_1,u_2\}\subseteq U$, $l \in L$ and $\{(u_1,l),$ $(l,u_2)\} \subseteq E$. The vertex $l$ is the middle vertex of the wedge. 
\end{definition}

\begin{definition}[\acrfull{awg}]\label{def:awg}
Let $G=((U\cup L),E)$ be a bipartite graph. An  \textit{aggregated wedge} is a pair $\la l, W_l \ra$, where $l \in L$, $W_l \subseteq U$ and for all $u\in W_l$, the edge  $(u,l)\in E$. 
\end{definition}

\begin{definition}[\acrfull{dwg}]
Let $G=((U\cup L),E)$ be a bipartite graph. A \textit{double-wedge} in $G$ is a path of length 4 $u_1,l_1,u_2,l_2,u_3$ where  $\{u_1,$ $u_2,u_3\}\subseteq U$ and $\{l_1,l_2\}\subseteq L$. Vertices $l_1$, $u_2$ and $l_2$ are the middle vertices of the double-wedge. 
\end{definition}
  
\begin{definition}[\acrfull{adwg}]\label{def:adwg}
Let $G=((U\cup L),E)$ be a bipartite graph and let $U_l = \la I, J, K\ra$ be a triplet such that $I \subseteq U, J \subseteq U$ and $K \subseteq U$, where $I, J$ and $K$ are disjoint sets. 
An \textit{aggregated double-wedge}  is a pair  $\la (l_1, l_2), U_l \ra$, where $\{l_1,l_2\}\subseteq L$ and  for all $u_i \in I, u_j \in J$ and $u_k \in K$, $\{(u_i, l_1), (u_j, l_1), (u_j, l_2), (u_k, l_2)\} \in E$.
\end{definition}

\begin{definition}[\acrfull{awgc}]\label{def:awgc}
Let $G=((U\cup L),E)$ be a bipartite graph and let $\la (l_1, l_2), U_l \ra$ be an Aggregated double-wedge, where $\{l_1,l_2\}\subseteq L$ and $U_l = \la I, J, K\ra$.
An Aggregated wedge $\la l, W_l \ra$ is an \textit{Aggregated wedge bi-triangle connector} \emph{if and only if} $l > l_1$ and $l < l_2$ and $W_l \cap (I \cup J) \neq \emptyset$ and $W_l \cap (K \cup J) \neq \emptyset$
\end{definition}
      
\begin{definition}[\acrfull{abt}]\label{def:abt}
Let $G=((U\cup L),E)$ be a bipartite graph and  $\hat{U}_l=\{\la I, J, K\ra | I \subseteq U, J \subseteq U, K \subseteq U\}$. An \textit{aggregated bi-triangle}  is a pair  $\langle \ell, \hat{U}_l\rangle$, 
where $\ell=(l_1, l_2, l_3)$ is a triple on $L$, $l_1 < l_2 < l_3$ and for all $\la I, J, K\ra$ and for all $\mu=(u_i, u_j, u_k)$ such that $u_i \in I, u_j \in J, u_k \in K$ and $u_i \neq u_j \neq u_k$, $BT_{\ell}^{\mu}\in \bt$.
\end{definition}

\begin{definition}[Query]
Let $G=((U\cup L),E)$ be a bipartite graph. 
Let $C=\{BT_V, BT_E\}$ be the set of possible query commands.
A \textit{query} $Q$ is an command $c \in C$, where 
\[
c = \left\{\begin{array}{lr}
BT_V, & BT_V \subseteq U\cup L\\
BT_E, & BT_E \subseteq E
\end{array}\right\} 
\]
It could be a command query of vertices or edges.
\end{definition}

\begin{definition}[Query Match]\label{def:query:match}
Let $G=((U\cup L),E)$ be a bipartite graph.
Let $Q$ be a query.
A query $Q$ matches in a bipartite graph $G$ if forall $BT_{(l_1,l_2,l_3)}^{(u_1,u_2,u_3)}$ of $G$
\[
Q = \left\{\begin{array}{lr}
BT_V, & \forall\ v \in BT_V, v \in \{u_1,u_2,u_3,l_1,l_2,l_3\}\\
BT_E, & \forall\ (u,l) \in BT_E, (u,l) \in \{(u_1, l_1), (u_2,l_1), (u_2, l_3), (u_3,l_3), (u_3, l_2), (u_1,l_2)\} 
\end{array}\right\} 
\]
\end{definition}

\begin{table}[!ht]
\centering
\begin{tabular}{|c|l|} \hline
\textbf{Notation} & \textbf{Meaning}\\ \hline
$G=((U\cup L),E)$ & a bipartite graph\\  \hline
$n,m$ & the number of vertices and edges in $G$, resp.\\  \hline
$(u,l)$ & an edge between vertices $u$ and $l$\\  \hline
$(u_1,l,u_2)$ & a wedge with  middle vertex $l$\\  \hline
$\la l, W_l \ra$ & an \acrshort{awg}\\  \hline
$\aw$ & the set of all the possible \acrshort{awg} in $G$\\  \hline
$(u_1,l_1,u_2,l_2,u_3)$ & a \acrshort{dwg} with middle vertices $l_1$ and $l_2$\\  \hline 
$\la (l_1, l_2), U_l \ra$ & an \acrshort{adwg}\\  \hline
$\dw$ & the set of all the possible \acrshort{adwg} in $G$\\  \hline
$\dwi$ & Subset of $\dw$, such that $\dwi \subseteq \dw$ \\  \hline
$\la (l_1, l_2,l_3), \hat{U}_l \ra$ & an \acrshort{abt}\\  \hline
$\at$ & the set of all the possible \acrshort{abt} in $G$ \\  \hline
$\ati$ & Subset of $\at$, such that $\ati \subseteq \at$ \\  \hline 
$\bti$ & the \acrshort{bt} $u_1,l_1,u_2,l_3,u_3,l_2,u_1$\\  \hline
$\bt$ & the set of all the possible \acrshort{bt} in $G$ \\  \hline
$bt$ & Subset of $\bt$, such that $bt \subseteq \bt$ \\  \hline
\end{tabular}
\caption{Summary of notations and their meanings}
\label{table:notation}
\end{table}
      

\subsection{Examples of Definitions}
Let us illustrate some of the previous definitions with a real \acrlong{bg} example. 
Lets suppose that we have the following \acrshort{bg} as it is shown in the \autoref{fig:bipartite-graph-example}.

\begin{figure}[ht]
\centering	
\inputtikz{bipartite}
\caption[Example of \acrshort{bg}]{Example of \acrshort{bg}}
\label{fig:bipartite-graph-example}
\end{figure}

As we can see, trying to identify the different \acrshort{bt} in this graph, it can be done manually, but in larger graphs can be more challenging.
If we use the previous structure definitions, we can detect that \acrshort {bt} in an easier and automated manner.
The first structure that we can detect is \acrshort{awg} as we can see on \autoref{fig:awedge-example}.

\begin{figure}[htp!]
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_a}
\caption{\acrshort{awg} on $a$}
\label{fig:awedge-example-a}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_b}
\caption{\acrshort{awg} on $b$}
\label{fig:awedge-example-b}
\end{subfigure}
\begin{subfigure}[b]{0.3\textwidth}
\centering
\inputtikz{bipartite_awg_c}
\caption{\acrshort{awg} on $c$}
\label{fig:awedge-example-c}
\end{subfigure}
\caption[Definitions Examples \acrshort{awg}]{Definitions Examples \acrshort{awg}}
\label{fig:awedge-example}
\end{figure}

As we can see on \autoref{fig:awedge-example}, we are only enumerating the first three lower layer vertices \acrshort{awg}.
Following that, we can build the \acrlong{adwg} as we can see in \autoref{fig:agg-double-wedge-example} to continue building the structure that lead us to the \acrshort{bt}.

\begin{figure}[htp!]
\centering
\inputtikz{bipartite_adwg_a}
\caption[Example Aggregated double-wedge]{Example Aggregated double-wedge}
\label{fig:agg-double-wedge-example}
\end{figure}

In \autoref{fig:agg-double-wedge-example} we can see the \acrshort{adwg} built by $a$ and $c$ where according to \dref{def:adwg} $a = l_1$ and $c = l_2$.
Now we can finally build our first \acrlong{abt} as we can see in the following \autoref{fig:agg-bt-example}.

\begin{figure}[htp!]
\centering      
\inputtikz{bipartite_abt_a}
\caption[Example Aggregated bi-triangle]{Example Aggregated bi-triangle}
\label{fig:agg-bt-example}
\end{figure}


\subsection{Algorithm Sketch}\label{sub:sec:algo-sketch}
Dynamic Pipeline Algorithm for Enumerating Bi-triangles ($\dpbt$) is defined in terms of the behavior of its four kinds stages: \textit{Source} ($\ibt$),  
\textit{Generator} ($\gbt$),  \textit{Sink} ($\obt$), and \textit{Filter}($\fbt$) stages. 
The algorithm considers a \acrlong{bt} as a convenient composition of three wedges.
In order to reduce memory footprint, the algorithm aggregates results, i.e. the set of wedges having the same middle vertex is represented as a pair $\la l, W_l \ra$ where $l$ is the middle vertex and $W_l$ is the set of adjacent vertices of $l$ called \acrfull{awg} (see \dref{def:awg}).
The algorithm first collects \acrshort{awg}, afterwards \acrshort{adwg} and finally \acrshort{abt} during the execution of the actors of $\fbt$ instance. 
The following table describes the different channels that are connecting the stages in $\dpbt$.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{0.2\linewidth}|p{0.8\linewidth}|} \hline
\textbf{Channel} & \textbf{Meaning}\\ \hline
$C = \la IC, OC \ra$ & A Channel pair that connects input and output channel\\ \hline
$OC$ & Set of Output Channels \\ \hline
$C_E$ & Channel of $e \in E$ \\ \hline
$IC_E$ & Input Channels carrying $e \in E$ \\ \hline
$OC_E$ & Output Channels carrying $e \in E$ \\ \hline
$C_{W_l1}$ & Channel of \acrshort{awg} \\ \hline
$IC_{W_l1}$ & Input Channels carrying \acrshort{awg} \\ \hline
$OC_{W_l1}$ & Output Channels carrying \acrshort{awg} \\ \hline
$C_{W_l2}$ & Channel of \acrshort{awg} \\ \hline
$IC_{W_l2}$ & Input Channels carrying \acrshort{awg} \\ \hline
$OC_{W_l2}$ & Output Channels carrying \acrshort{awg} \\ \hline
$C_Q$ & Channel of $Q$ Command \\ \hline
$IC_Q$ & Input Channels carrying $Q$ Command \\ \hline
$OC_Q$ & Output Channels carrying $Q$ Command \\ \hline
$C_{BT}$ & Channel of $\bt$ \\ \hline
$IC_{BT}$ & Input Channels carrying $\bt$ \\ \hline
$OC_{BT}$ & Output Channels carrying $\bt$ \\ \hline
\end{tabular}
\caption{Summary of Channels used in \acrshort{dpbt}}
\label{table:channels}
\end{table}

\begin{definition}[Filter State]
Let $G=((U\cup L),E)$ be a bipartite graph. 
Let $\aw$ be a set of all possibles Aggregated wedges in $G$.
Let $\dw$ be a set of all possibles Aggregated double-wedges in $G$.
Let $\at$ be a set of all possibles Aggregated bi-triangles in $G$.
An \textit{filter state} of \acrshort{dp} Filter with parameter $l$ is a sum type $\st = \la l, W_l \ra + \dwi + \ati$, such that $\la l, W_l \ra \in \aw, \dwi \subseteq \dw, \ati \subseteq \at$.
\end{definition}
 
\begin{figure}[h]
\centering  
\inputtikz{btDP}
\caption{$\dpbt$ Initial setup}
\label{fig:btDP}
\end{figure}

\paragraph{Sketch} The setup of \acrshort{dp} can be appreciated in \autoref{fig:btDP}. $\ibt$ reads from input stream all $(u,l) \in E$ in an incremental non-blocking manner and transfer to the following stage each $(u,l)$ using $C_E$.
For every $(u,l)$ that arrives to $\gbt$, a new $\fbt$ instance with parameter $l \in L$ is spawn. $\fbt$ contains four actors. 
First, $\aaa$ receives from $IC_E$ the edges and builds \acrshort{awg} downstreaming to $\fbt$ using $OC_{W1}$. 
Then $\ab$ receives from $IC_{W1}$ aggregated wedges from previous $\fbt$, downstream to next $\fbt$ and $\gbt$ using $OC_{W1}$ and at the same time use its information to see 
if it can build \acrshort{adwg}. If it can, it will store in its $\st$ those $dw \in \dw$.

$\ab$ downstream the \acrshort{awg} to  $\fbt$ and $\gbt$. This is because we need to retro feed all the pipeline with all the \acrshort{awg}, in order to find \acrshort{awgc} as we defined in \dref{def:awgc}.
From retro feeding channel $IC_{W2}$, $\ac$ receives all the \acrshort{awg} again and builds \acrshort{abt} storing them in $\st$. 
$Q$ Commands are downstream from $\ibt$ to $\ad$ using channel $IC_Q$. $\ad$ receives all the commands, and for each of them, if there is match according to \dref{def:query:match}, it enumerates those \acrshort{bt} extracted from $\st$ and downstream to $\obt$ through $OC_{BT}$.

\subsection{Dynamic Pipeline for Enumerating Bi-triangles}
In this section, we present all the pseudo-code definitions of each of the stages described previously in ~\autoref{sub:sec:algo-sketch}. 
In spite of this work has been implemented using \acrshort{hs}, and in particular \acrshort{dpfh}, the pseudo-code algorithms presented here are language independent.
Before starting with the details, we introduce in \autoref{table:aux:fn} auxiliary functions that are language-specific, and therefore there are only listed and not detailed.

\begin{table}[!htp]
\centering
\begin{tabular}{|p{0.3\linewidth}|p{0.7\linewidth}|} \hline
\textbf{Function} & \textbf{Meaning}\\ \hline
$\sw(F,l,\st)$ & Spawn new filter instance with parameters $F$ (Filter template), $l \in L$ and $\st$ as the State of the Filter\\\hline
$\fd$ & Kill this filter instance because PostCondition does not fullfil\\ \hline
$\fid$ & State after calling $\fd$ on filter. Indicates if Filter is die or not. If it is dead, this filter instance does not participate anymore in the pipeline streaming processor\\ \hline
$\gs$ & Get Current State $\st$ for Filter Instance \\ \hline
$\us(\st)$ & Update Current State $\st$ for Filter Instance \\ \hline
$\p(\mathtt{v}, OC_x)$ & push some value $\mathtt{v}$ to some Output Channel $OC_x$ \\\hline
$\mt(Q, BT)$ & Check if a Query $Q$ matches over $BT$ \\ \hline
\end{tabular}
\caption{Summary of auxiliary functions for handling \acrshort{dpbt} internals}
\label{table:aux:fn}
\end{table}
      
\begin{algorithm}
\SetKwInOut{P}{Input Data}
\SetKwInOut{Q}{Input Commands}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetAlgorithmName{}{src}{}
\SetAlgoRefName{[A1]}
\P{$IO_E$: File or Input Stream with Set of Edges $E$}
\Q{$IO_Q$: File or Input Stream with Commands $Q$}
\IC{$IC = \la IC_{W_l2} \ra$}
\OC{$OC = \la OC_E, OC_{W_l2}, OC_Q \ra$}
\ForAll(\tcp*[f]{Edges to Generator/Filter}){$(u,l) \in IO_E$}
{$\p((u,l), OC_E)$ \label{algo:source:1}
}
\ForAll(\tcp*[f]{Feedback from Generator to Filter}){$\la l, W_l \ra \in IC_{W_l2}$}
{$\p(\la l, W_l \ra, OC_{W_l2})$ \label{algo:source:2}
}
\ForAll(\tcp*[f]{Send Query Commands}){$Q \in IO_Q$}
{$\p(Q, OC_Q)$ \label{algo:source:3}
}
\caption{Source ($\ibt$)}
\label{algo:source}
\end{algorithm}

\paragraph{Source $\ibt$} In \autoref{algo:source} we can see in \autoref{algo:source:1} how the edges arriving from the input stream of the graph are downstream to the pipeline. 
Another important part as well is \autoref{algo:source:2}, the $\ibt$ is retro feed with \acrshort{awg} stream that is generated during pipeline execution.
This is important to finally build the \acrshort{bt} as we have describe in \autoref{sub:sec:algo-sketch}. Finally, \autoref{algo:source:3} shows how all the queries are downstream as well.

\begin{algorithm}
\SetKwInOut{P}{Filter Template}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetAlgorithmName{}{gen}{}
\SetAlgoRefName{[A2]}
\P{$F$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_Q, IC_{BT} \ra$}
\OC{$ OC = \la OC_{W_l2}, OC_{BT} \ra$}
\ForAll{$(u,l) \in IC_E$}
{$\sw(F, l, \la l, \{u\} \ra)$ \label{algo:gen:1}
}
\ForAll(\tcp*[f]{Feedback channel to retrofit Source}){$\la l, W_l \ra \in IC_{W_l1}$}
{$\p(\la l, W_l \ra, OC_{W_l2})$ \label{algo:gen:2}
}
\ForAll{$\bti \in IC_{BT}$}
{$\p(\bti, OC_{BT})$ \label{algo:gen:3}
}
\caption{Generator ($\gbt$)}
\label{algo:gen}
\end{algorithm}

\begin{figure}[h]
\centering  
\inputtikz{btDP_actor1}
\caption{$\dpbt$ With Filter instances}
\label{fig:btDP_actor1}
\end{figure}

\paragraph{Generator $\gbt$} $\gbt$ also have three main loops. In \autoref{algo:gen:1} it receives each edge $(u,l)$ not consumed by any $\fbt$, and 
spawns a new $\fbt$ using $l \in L$ as filter parameter and initializing $\st = \la l, \{u\} \ra$ as it can be seen in \autoref{fig:btDP_actor1}. 
Spawn assumes that, the implementation will connect the channels to keep the downstream correct. Defines all the input channels of $\gbt$ as input channels of the newly spawn $\fbt$ and set $\fbt$'s output channels as $\gbt$ input channels.
In \autoref{algo:gen:2} we can see how the algorithm is receiving and retro feeding $\ibt$ with all the \acrshort{awg}. This also assumes that $OC_{W2}$ in $\gbt$ 
is connected with $IC_{W2}$ in $\ibt$.
Finally, \autoref{algo:gen:3} sends all the results that $Q$ matches in the different filters to $\obt$.

\begin{algorithm}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{O}{Output}
\SetAlgorithmName{}{sink}{}
\SetAlgoRefName{[A3]}
\O{$IO_{BT}$: File or Output Stream with $BT$}
\IC{$IC = \la IC_{BT} \ra$}
\ForAll(\tcp*[f]{Read Results and put in $IO_{BT}$}){$\bti \in IC_{BT}$}
{$put(\bti, IO_{BT})$
}
\caption{Sink ($\obt$)}
\label{algo:sink}
\end{algorithm}

\paragraph{Sink $\obt$} In \autoref{algo:sink} shows a simple stage that receives all results and sends them to some output handler (file, standard output, etc.). 

\begin{algorithm}
\SetKwInOut{P}{Filter Template}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwFunction{actora}{actor1}
\SetKwFunction{actorb}{actor2}
\SetKwFunction{actorc}{actor3}
\SetKwFunction{actord}{actor4}
\SetKwFunction{filter}{filter}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fil}{}
\SetAlgoRefName{[A4]}
\P{$l \in L$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\df{\filter{}}{
      $\actora()$\\
      $\actorb()$\\
      $\actorc()$\\
      $\actord()$\\
}
\caption{Filter ($\fbt$)}
\label{algo:fil}
\end{algorithm}

\paragraph{Filter $\fbt$} In \autoref{algo:fil} shows the simple call sequence over all the actor functions of the filter template. 

\begin{figure}[h]
\centering  
\inputtikz{btDP_actor1}
\caption{$\dpbt$ With Filter instances}
\label{fig:btDP_actor1}
\end{figure}
      

\begin{algorithm}
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{acta}{actor1}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa1}{}
\SetAlgoRefName{[A5]}
\P{$l \in L$}
\FS{$\la l, W_l \ra$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\PC{$|W_l| > 1 \lor \fid$}
\BlankLine
\df{\acta{}}{
$\la l, W_l \ra \leftarrow \gs$\\
\ForAll{$(u',l') \in IC_E$}
{\uIf{$l = l'$}{$W_l \leftarrow W_l \cup \{u'\}$}\label{algo:act-1:1}
}
\uIf{$|W_l| > 1$}{
      $\us(\la l, W_l \ra)$\\ \label{algo:act-1:2}
      $\p(\la l, W_l \ra, OC_{W_l1})$\\
}\Else{$\fd$}
}
\caption{Actor1 ($actor_1$)}
\label{algo:act-1}
\end{algorithm}

\paragraph{Filter $\aaa$} As we have described in \autoref{sub:sec:algo-sketch} and it according to \autoref{algo:act-1:1}, $\aaa$ is receiving all edges 
and if the $l' \in L$ of the new received edge is the same as the filer parameter $l$ then it will add to the list of \acrshort{awg} the $u' \in U$ received. 
In \autoref{algo:act-1:2} the state is updated and \acrshort{awg} downstream, if and only if at least 1 wedge could be collected. Otherwise, the filter is marked as dead with $\fd$ function.

\begin{algorithm}
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actb}{actor2}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa2}{}
\SetAlgoRefName{[A6]}
\P{$l \in L$}
\FS{$\la l, W_l \ra$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
\BlankLine
\PrC{$W_l \subseteq U, |W_l| > 1$}
\PC{$|\dwi| \geq 1 \lor \fid$}
\df{\actb{}}{
$\la l, W_l \ra \leftarrow \gs$\\
\ForAll{$\la l', W_l' \ra \in IC_{W_l1}$}{
      \tcp*[h]{By pass Wedges from previous filters to next ones}
      $\p(\la l', W_l \ra, OC_{W_l1})$\\
      $\dwi \leftarrow \emptyset$\\
      \If{$l \neq l' \land W_l' \cap W_l \neq \emptyset$}{ \label{algo:act-2:1}
            $(l_l, l_u) \leftarrow (\argmin_{l,l'}, \argmax_{l,l'})$\\
            \uIf{$l < l'$}{
                  $(W_{l_l}, W_{l_u}) \leftarrow (W_l, W_l')$
            }\Else{
                  $(W_{l_l}, W_{l_u}) \leftarrow (W_l', W_l)$
            }
            $I \leftarrow W_{l_l} \setminus W_{l_u}$\\ \label{algo:act-2:2}
            $J \leftarrow W_{l_l} \cap W_{l_u}$\\
            $K \leftarrow W_{l_u} \setminus W_{l_l}$\\ \label{algo:act-2:3}
            $U_l \leftarrow \la I, J, K\ra$\\
            $\dwi \leftarrow dw \cup \{\la (l, l'), U_l \ra\}$
      }
}
\uIf{$\dwi = \emptyset$}{$\fd$}
\Else{$\us(\dwi)$}
}
\caption{Actor2 ($actor_2$)}
\label{algo:act-2}
\end{algorithm}

\paragraph{Filter $\ab$} In \autoref{algo:act-2} \acrshort{adwg} is built. Following that idea and according to the \dref{def:adwg}, this algorithm will collect all the \acrshort{awg} 
from previous filters if an only if the condition in \autoref{algo:act-2:1} is met. The first check on $l$ and $l'$ would be avoided because by \acrshort{dp} nature
only one filter instance is responsible of collecting \acrshort{awg} of its $l$. $W_l$ intersection check is mandatory since if \acrshort{awg} are disjoint, we cannot aggregate them.
After this checking from \autoref{algo:act-2:2} to \autoref{algo:act-2:3}, the algorithm is building three disjoint Sets to separate upper edges in three subsets; those which are incident only of 
$l$ and $l'$ which are $I$ and $K$ and those that are shared by both lower layer vertex. This can be appreciated in \autoref{fig:agg-double-wedge-example}.
Once \acrshort{adwg} is built $\st = \dwi$ updating the state for the next $\ac$.

\begin{algorithm}
\DontPrintSemicolon
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actc}{actor3}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa3}{}
\SetAlgoRefName{[A7]}
\P{$l \in L$}
\FS{$\dwi \subseteq \dw$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}  
\BlankLine
\PrC{$|\dwi| \geq 1$}
\PC{$|\ati| \geq 1 \lor \fid$}
\df{\actc{}}{
      $\dwi \leftarrow \gs$\\
      $\ati \leftarrow \emptyset$\\
      \ForAll{$\la l', W_l \ra \in IC_{W_l2}$}{
            \tcp*[h]{By pass to be used by following Filters}
            $\p(\la l', W_l \ra, OC_{W_l2})$\\ 
            \tcp*[h]{For each double wedge in State}\\
            \ForEach{$\la (l_l, l_u), \la I, J, K \ra \ra \in \dwi, l_l < l' \land l_u > l'$}{
                  $I' \leftarrow I \cup J$\\
                  $K' \leftarrow K \cup J$\\
                  \If{$W_l \cap I' \neq \emptyset \land W_l \cap K' \neq \emptyset$}{
                        $I' \leftarrow I' \cap W_l$\\
                        $K' \leftarrow K' \cap W_l$\\
                        $\hat{U}_l  \leftarrow \hat{U}_l \cup \{\la I', J, K' \ra\})$
                  }
                  \If{$\hat{U}_l \neq \la \emptyset,\emptyset,\emptyset \ra$}{
                        $\ati \leftarrow \ati \cup \{\la (l_l, l', l_u), \hat{U}_l \ra\}$
                  }
            }
      }
      \uIf{$\ati = \emptyset$}{$\fd$}
      \Else{$\us(\ati)$\\}
}
\caption{Actor3 ($actor_3$)}
\label{algo:act-3}
\end{algorithm}

\paragraph{Filter $\ac$} $\ac$ focuses on treating elements from feedback channel $IC_{W2}$ which is going to downstream all the \acrshort{awg} of all filters.
This is because in order to build \acrshort{abt} finding all the possibles \acrshort{awgc}. This is what is doing \autoref{algo:act-3} according to definition 
\dref{def:awgc} and \dref{def:abt}. If that can be achieve, algorithm sets $\st = \ati$ and $\ad$ can be executed.

\begin{algorithm}
\SetKwInOut{P}{Parameter}
\SetKwInOut{IC}{Input Channels}
\SetKwInOut{OC}{Output Channels}
\SetKwInOut{FS}{$\st$}
\SetKwInOut{PC}{Post-Cond}
\SetKwInOut{PrC}{Pre-Cond}
\SetKwFunction{actc}{actor4}
\SetKwFunction{butV}{buildBtVertex}
\SetKwFunction{butE}{buildBtEdge}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{fa4}{}
\SetAlgoRefName{[A8]}
\P{$l \in L$}
\FS{$\ati \subseteq \at$}
\IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
\OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}  
\BlankLine
\PrC{$|\ati| \geq 1$}
\df{\actc{}}{
$\ati \leftarrow \gs$\\
\ForAll{$Q \in IC_Q$}{
      \ForEach{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati$}{
            \Switch{$Q$}{
                  \Case{$BT_V$}{
                        \If{$BT_V \cap \{l_l, l_m, l_u\} \neq \emptyset \lor BT_V \cap (I \cup J \cup K) \neq \emptyset$}{
                              $\btii \leftarrow \butV(\la (l_l, l_m, l_u), \la I,J,K \ra \ra), BT_V)$\\
                              \ForAll{$\bti \in \btii$}{
                                    $\p(\bti, OC_{BT})$
                              }
                        }
                  }
                  \Case{$BT_E$}{
                        \ForEach{$(u,l) \in BT_E$}{
                              \If{$(l = l_l \lor l = l_m \lor l = l_u) \land u \in (I \cup J \cup K)$}{
                                    $\btii \leftarrow \butE(\la (l_l, l_m, l_u), \la I,J,K \ra \ra), (u,l))$\\
                                    \ForAll{$\bti \in \btii$}{
                                          $\p(\bti, OC_{BT})$
                                    }
                              }
                        }
                  }
            }
      }
}
}
\caption{Actor4 ($actor_4$)}
\label{algo:act-4}
\end{algorithm}

\paragraph{Filter $\ad$} Once the execution reaches $\ad$, it is ready for processing $Q$ commands. Since we have a compress representation of \acrshort{bt}, which is a similar idea exposed here~\cite{Lai}, if a command $Q$ arrives in order 
to enumerate incrementally \acrshort{bt} that matches the command, we need to build them on demand with the format used on \dref{def:bt}.

The following pseudo-code definitions on \autoref{algo:buildBtVertex} and \autoref{algo:buildBtEdge} are auxiliary functions that are called
from $\ad$ if $Q$ pattern match either with $BT_V$ or $BT_E$.

\begin{algorithm}
\SetKwInOut{I}{Input}
\SetKwInOut{O}{Output}
\SetKwFunction{but}{buildBtVertex}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{a1}{}
\SetAlgoRefName{[A9]}
\I{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati, \ati \subseteq \at$}
\I{$BT_V$}
\O{$\btii \subseteq \bt$ or $\emptyset$ if cannot build any $\btii$}
\df{\but{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, $BT_V$}}{
      $\btii \leftarrow \emptyset$\\
      \uIf{$BT_V \cap \{l_l, l_m, l_u\}$}{
            \tcp*[h]{If it is in lower i need to build all for this lower triplet}\\
            \ForEach{$i \in I$}{
                  \ForEach{$j \in J, j \neq i$}{
                        \ForEach{$k \in K, k \neq i \land k \neq j$}{
                              $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                        }
                  }
            }
      }\Else{
            \tcp*[h]{Otherwise just build those that are in the this upper $v$}\\
            \ForEach{$i \in I$}{
                  \ForEach{$j \in J, j \neq i$}{
                        \ForEach{$k \in K, k \neq i \land k \neq j \land (BT_V \cap \{i,j,k\} \neq \emptyset$}{
                              $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                        }
                  }
            }
      }
      \Return{$\btii$}
}
\caption{Function \mintinline{shell}{buildBtVertex}}
\label{algo:buildBtVertex}
\end{algorithm}

\begin{algorithm}
\SetKwInOut{I}{Input}
\SetKwInOut{O}{Output}
\SetKwFunction{but}{buildBtEdge}
\SetKwFunction{he}{hasEdge}
\SetKwProg{df}{def}{:}{end}
\SetAlgorithmName{}{a2}{}
\SetAlgoRefName{[A10]}
\I{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati, \ati \subseteq \at$}
\I{$(u,l)$}
\O{$\btii \subseteq \bt$ or $\emptyset$ if cannot build any $\btii$}
\df{\but{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra$, $BT_V$}}{
      $\btii \leftarrow \emptyset$\\
      \ForEach{$i \in I$}{
            \ForEach{$j \in J, j \neq i$}{
                  \ForEach{$k \in K, k \neq i \land k \neq j \land \he((u,l), (l_l,l_m,l_u),(i,j,k))$}{
                        $\btii \leftarrow \btii \cup \{BT_{(l_l, l_m,l_u)}^{(i, j, k)}\}$
                  }
            }
      }
      \Return{$\btii$}
}
\df{\he{$(u,l), (l_l,l_m,l_u), (i,j,k)$}}{
      \If{$(u,l) = (l_l, i) \lor (u,l) = (l_l, j) \lor (u,l) = (l_u, j) \lor (u,l) = (l_u, k) \lor (u,l) = (l_m, i) \lor (u,l) = (l_m, k)$}{
            \Return{True}
      }\Else{
            \Return{False}
      }
}
\caption{Function \mintinline{shell}{buildBtEdge}}
\label{algo:buildBtEdge}
\end{algorithm}

\clearpage
\section{Complexity Analysis of Algorithm}
This complexity analysis does not provide an analysis of the algorithm as a whole with all the details of \acrshort{dp} model included.
Just the opposite, we are only limiting the analysis to the specific functions without taking into consideration neither the context of the parallelization model nor \acrshort{dp}.

Having said that, we are going to conduct the complexity analysis of the algorithm focusing on each stage. 
$\fbt$ stage is going to be analyzed with all its actor as a single stage.

\begin{theorem}[$|\aw| \leq |L|$]\label{theorem:awg}
The size of all possible aggregated wedges is upper bound by $|L|$.
\end{theorem}
\begin{proof}
Obvious by \dref{def:awg} since at most each $l \in L$ is participating on a wedge.
\end{proof}

\begin{proposition}[Complexity on Source $\ibt$]\label{prop:comp-src}
The total complexity of $\ibt$ algorithm in worst-case is $O(|E|)$.
\end{proposition}
\begin{proof}
In the case of this stage we have three loops. The first one is the number of edges of the graph $|E|$, the second in the number 
of possible \acrshort{awg} which is $|L|$ because of \autoref{theorem:awg}.
And the last is the amount of $Q$, then worst-case complexity is $O(|E| + |L| + |Q|)$.
Since $|L| \leq |E|$ by \dref{def:bt} and $|Q| << |E|$ because otherwise the user will be able to manually inspect the whole graph and we are in a \emph{pay-as-you-go} model
as we have described in \autoref{relate-work}.
Therefore, $O(|E|)$ 
\end{proof}

\begin{proposition}[Complexity on Generator $\gbt$]
The total complexity of $\gbt$ algorithm in worst-case is $O(|E| + |\bt|)$.
\end{proposition}
\begin{proof}
$\gbt$ could receive potentially all edges, then there is a worst case cost of $|E|$.
After that it will receive all $|L|$ worst case, as we have seen in \autoref{theorem:awg}.
Finally, it will receive all possible $\bti \subseteq \bt$. Then worst-case complexity is $O(|E| + |\bt| + |L|)$.
For same reason in \pref{prop:comp-src} $|L|$ can be discarded, therefore complexity is $O(|E| + |\bt|)$.
\end{proof}

\begin{proposition}[Complexity on Sink $\obt$]
The total complexity of $\obt$ algorithm in worst-case is $O(|\bt|)$.
\end{proposition}
\begin{proof}
Obvious by definition of \autoref{algo:sink}.
\end{proof}

\begin{proposition}[Complexity of Filter $\fbt$]
The total complexity of $\fbt$ algorithm in worst-case is $O(\binom{|L|}{2} \times 3|U| + \binom{|V|}{6})$.
\end{proposition}
\begin{proof}
Since actors in filters are executed sequentially, the complexity of $\aaa$ is $O(|E|)$ by \dref{algo:act-1}.
Then for $\ab$ complexity is $O(3|U|)$ because of intersection and difference operation on Set inside the loop is $O(m+n)$ each. 
Since $|U| = m = n$ worst case, then the cost of each loop is $O(3|U|)$.  
The complexity of $\ac$ is $O(\binom{|L|}{2} \times 3|U|)$. For building all possible $\dw$ we need all possible combinations of $|L|$ taken by $2$ worst case, times the complexity of building for each case the three sets of incident edges.
Finally for building all possible $\bt$ in $\ad$ worst case is $O(\binom{|V|}{6})$.
\end{proof}
      
      
\clearpage
\section{Draft-Correctness of the Algorithm}
Given a \acrshort{bt} $BT_{\ell}^{\mu} = \bti$ as we defined in \dref{def:bt}, where the 6-cycle is $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$.

%A bi-triangle can be described as a sequence $(C,a,A,b,B,c,C)$  where $\{ a,b,c\} \in L$  and $\{ A,B,C\} \in U\footnote{In the enumeration, L and $U$ be interchanged}$

We need to prove that the algorithm can enumerate all bi-triangle in the graph and also that there are no duplicates in the enumeration.

\begin{quote}
Very recently, Qiao
et al. proposed CrystalJoin~\cite{Lai} that aims at resolving the
output crisis by compressing them.
\end{quote}

We use the same technique, compressing a group of bi-triangles as we define in \dref{def:abt} $\langle \ell, \hat{U}_l\rangle$, where $\ell = (l_1,l_2,l_3,)$ and $\hat{U}_l=\{\la I, J, K\ra | I \subseteq U, J \subseteq U, K \subseteq U\}$ ($\aw$).
 

First we are going to prove that if we take all the triples $(l_1,l_2,l_3)$  such $l_1<l_2$ and $l_2<l_3$  and  $\la (l_1,l_2,l_3,), \hat{U}_l \ra$ is an aggregate  bi-triangle, then it is not stored twice (theorem \ref{TH-unicity}). 
We will show that we store all the aggregate bi-triangles where $u_1,u_2,u_3$  are distinct and $u_1$ is incident to $l_1$ and $l_2$, $u_2$ is incident to $l_1$ and $l_3$ and $u_3$ is incident to $l_2$ and $l_3$ (theorem \ref{TH-all}). 
\begin{theorem} \label{TH-unicity}Every aggregated bi-triangle is stored  at most once 

\end{theorem}
\begin{proof}
As a bi-triangle is a 6-closed cycle it can be described as a sequence of nodes  $(u_3,l_1,u_1,l_2,u_2,l_3,u_3)$, each one adjacent to its neighbour. For every feasible permutation  starting with a node in $U$ we are going to proof that only one will be accepted by $\ab$ .  
\begin{itemize}
    \item $(u_1,l_2,u_3,l_3,u_2,l_1,u_1)$ not accepted because $l_3 > l_1$
    \item $(u_3,l_2,u_1,l_1,u_2,l_3,u_3)$ not accepted because $l_2 > l_1$
    \item $(u_3,l_3,u_2,l_1,u_1,l_2,u_3)$ not accepted because $l_3 > l_1$ and $l_3 > l_2$
    \item $(u_2,l_3,u_3,l_2,u_1,l_1,u_2)$ not accepted because $l_3 > l_1 $
    \item $(u_2,l_1,u_1,l_2,u_3,l_3,u_2)$ is accepted because $l_1 < l_3 $ in actor 2 of filter $F_a$ or $F_c$ and $l_1 < l_2 <l_3$  in actor 3
    \item $(u_1, l_1,u_2,l_3,u_3,l_2,u_1)$ not accepted because $l_3 > l_1$
\end{itemize}


Therefore the  only sequence constructed by the algorithm is the one that satisfies $l_1 < l_2 < l_3$ where $u_1,u_2,u_3$  are distinct and $u_1$ is incident to $l_1$ and $l_2$, $u_2$ is incident to $l_1$ and $l_3$ and $u_3$ is incident to $l_2$ and $u_3$.
\end{proof}


\begin{theorem}\label{TH-all}Every bi-triangle present in the graph is listed.

\end{theorem}

\begin{proof}

Obvious from the definition of $I,J,K$  and the algorithm of obtaining bi-triangles. 
\iffalse
Lets assume that a bi-triangle $(a,A,b,B,c,C)$   will assume that $a$ is the smallest element in the set $\{a,b,c\}$ and $c$ is the bigger.
When actor 1 in fiter $F_a$1 ends reading all the edges, $\{A,B\} \subseteq W_a$. Also When actor 1 in fiter $F_c$1 ends reading all the edges, $\{B,C\} \subseteq W_c$. 

AS $a < c$  in filter $F_a$ the pair $(a,c)$  will be added to D
$DW$. When actor 3 in filter $F_a$ receives $(b, W_b)$ will add to $BT$ because of the non empty intersection. Therefore the bi-triangle $(a,A,b,B,c,C)$ can be recognized
\fi
\end{proof}

----------------

Second version
 So we are going to talk from now on of the bi-triangles stored in  filter $F_a$.

 At the end of the execution of actor 3 $F_a$ constructs the sets where to choose $A,B,C$
 
 Actor 1 collects in $F_a$ all the nodes in $U$ adjacent to $a$ i.e. all the candidates to choose $A$. Afterwards this set will be reduced . 
 
 Actor 2 receives pairs $(c,V)$ where $V$ are all the nodes adjacent to $c$ in order to test the possibility of constructing a new double wedge.  If the conditions are fulfilled, it adds the double wedge $\la (a,c), l_2), U_{t_1} \ra$,  or $\la (c, a), U_{t_2} \ra$. 
 
 In each filter, the pair of lower vertices in the double edges are pairs constructed by $a$ and vertices that are parameters of filters that are before the filter $F_a$. Therefore, the double edges recorded are present in at most one filter.
 
 Actor 3 receives pairs $(b,M) $ where $M$ are all the nodes adjacent to $b$ and has in memory a set of double wedges $\la (a,c), l_2), U_{t_1} \ra$
 
 $\ab$ accepts b as a candidate to construct an element of the set of aggregate bi-triangles if $a < b < c$. Therefore the aggregated bi-triangles so constructed are recorded in a single filter due to the fact that that the pair $(a,c)$ is present in a single filter.
 
 
\section{\acrshort{dpbt} implementation}
As we have seen in the previous \autoref{dp-hs}, first we need to define the \acrshort{dp} using the \acrshort{dsl}.

\begin{listing}[H]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={3}]{haskell}

type DPBT = Source (Channel (Edge :<+> W :<+> Q :<+> BT :<+> BTResult :<+> W :<+> Eof))
      :=> Generator (Channel (Edge :<+> W :<+> Q :<+> BT :<+> BTResult :<+> Eof))
      :=> FeedbackChannel (W :<+> Eof)
      :=> Sink

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] Enconding of \acrshort{dpbt}}
\label{src:dpbt:1}
\end{listing}

In \autoref{src:dpbt:1} can be appreciated the use of retro feed channel in the highlighted line. 
Automatically \acrshort{dpbt} is going to connect this with the $\ibt$.

$\ibt, \obt, gbt$ are not going to be covered because they are straightforward to follow from the code. 
The main part of the algorithmic complexity, as we have seen in the pseudo-code, relies on actor filter.

\begin{listing}[H]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={16,21}]{haskell}

actor1 :: Edge
      -> ReadChannel (UpperVertex, LowerVertex)
      -> ReadChannel W
      -> ReadChannel Q
      -> ReadChannel BT
      -> ReadChannel BTResult
      -> ReadChannel W
      -> WriteChannel (UpperVertex, LowerVertex)
      -> WriteChannel W
      -> WriteChannel Q
      -> WriteChannel BT
      -> WriteChannel BTResult
      -> WriteChannel W
      -> StateT FilterState (DP st) ()
actor1 (_, l) redges _ _ _ _ _ we ww1 _ _ _ _ = do
 foldM_ redges $ \e@(u', l') -> do
   e `seq` if l' == l then modify $ flip modifyWState u' else push e we
 finish we
 state' <- get
 case state' of
   Adj w@(W _ ws) -> when (IS.size ws > 1) $ push w ww1
   _              -> pure ()

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\aaa$}
\label{src:dpbt:2}
\end{listing}

In \autoref{src:dpbt:2} $\aaa$ source code can be appreciated. Since all the actors are inside the same filter context, all of them has access to read and write
channels of all the filters. That explains the number of parameters which is generated by the \acrshort{idl}.
The first highlighted line is the catamorphism (\mintinline{haskell}{foldM_}) of the $IC_E$ channel. 

\begin{listing}[H]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={22,30,36}]{haskell}

actor2 :: Edge
      -> ReadChannel (UpperVertex, LowerVertex)
      -> ReadChannel W
      -> ReadChannel Q
      -> ReadChannel BT
      -> ReadChannel BTResult
      -> ReadChannel W
      -> WriteChannel (UpperVertex, LowerVertex)
      -> WriteChannel W
      -> WriteChannel Q
      -> WriteChannel BT
      -> WriteChannel BTResult
      -> WriteChannel W
      -> StateT FilterState (DP st) ()
actor2 (_, l) _ rw1 _ _ _ _ _ ww1 _ _ _ _ = do
 state' <- get
 case state' of
   Adj (W _ w_t) -> do
     modify $ const $ DoubleWedges mempty
     foldM_ rw1 $ \w@(W l' w_t') -> do
       push w ww1
       buildDW w_t w_t' l l'
     finish ww1
   _ -> pure ()

buildDW :: IntSet -> IntSet -> LowerVertex -> LowerVertex -> StateT FilterState (DP st) ()
buildDW w_t w_t' l l' =
let pair       = Pair (min l l') (max l l')
      paramBuild = if l < l' then (w_t, w_t') else (w_t', w_t)
      ut         = uncurry buildDW' paramBuild
in  if (IS.size w_t > 1) && l /= l' && not (IS.null (IS.intersection w_t w_t')) && not (nullUT ut)
      then modify $ flip modifyDWState (DW pair ut)
      else pure ()

buildDW' :: IntSet -> IntSet -> UT
buildDW' !w_t !w_t' = (w_t IS.\\ w_t', IS.intersection w_t w_t', w_t' IS.\\ w_t)

\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ab$}
\label{src:dpbt:3}
\end{listing}

In \autoref{src:dpbt:3}, the interesting part of $\ab$ is the construction of $\dwi$. That is done by the function \mintinline{haskell}{buildDW}
and \mintinline{haskell}{buildDW'} which are building the three subsets required to build $\dwi$.

\begin{listing}[H]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={27,34-40}]{haskell}      
actor3 :: Edge
       -> ReadChannel (UpperVertex, LowerVertex)
       -> ReadChannel W
       -> ReadChannel Q
       -> ReadChannel BT
       -> ReadChannel BTResult
       -> ReadChannel W
       -> WriteChannel (UpperVertex, LowerVertex)
       -> WriteChannel W
       -> WriteChannel Q
       -> WriteChannel BT
       -> WriteChannel BTResult
       -> WriteChannel W
       -> StateT FilterState (DP st) ()
actor3 (_, l) _ _ _ _ _ rfb _ _ _ _ _ wfb = do
  state' <- get
  case state' of
    DoubleWedges dwtt -> do
      modify $ const $ BiTriangles mempty
      foldM_ rfb $ \w@(W l' w_t') -> do
        push w wfb
        when (hasDW dwtt) $ do
          let (DWTT dtlist) = dwtt
          forM_ dtlist $ \(DW (Pair l_l l_u) ut) ->
            let triple = Triplet l_l l' l_u
                result =
                  if l' < l_u && l' > l_l then filterUt w_t' ut else Nothing
            in  maybe (pure ()) (modify . flip modifyBTState . BT triple) result
      finish wfb
    _ -> pure ()

filterUt :: IntSet -> UT -> Maybe UT
filterUt wt (si, sj, sk) =
  let si' = IS.filter (`IS.member` wt) si 
      sj' = IS.filter (`IS.member` wt) sj
      sk' = IS.filter (`IS.member` wt) sk
      sij' = si' `IS.union` sj'
      sjk' = sk' `IS.union` sj'
      wtInSome = not (IS.null sij' || IS.null sjk')
  in  if wtInSome then Just (sij', sj, sjk') else Nothing
\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ac$}
\label{src:dpbt:4}
\end{listing}

$\ac$ in \autoref{src:dpbt:4}, shows the build $\ati$ and in highlighted lines we can see the algorithm to detect when the \acrshort{awg}
received in the feedback channel are \acrshort{awgc} according to \dref{def:awgc}.

\begin{listing}[H]
\begin{minted}[fontsize=\small,numbers=left,breaklines,frame=lines,framerule=2pt,framesep=2mm,baselinestretch=1.2,highlightlines={21-22,27-31}]{haskell}            
actor4 :: Edge
       -> ReadChannel (UpperVertex, LowerVertex)
       -> ReadChannel W
       -> ReadChannel Q
       -> ReadChannel BT
       -> ReadChannel BTResult
       -> ReadChannel W
       -> WriteChannel (UpperVertex, LowerVertex)
       -> WriteChannel W
       -> WriteChannel Q
       -> WriteChannel BT
       -> WriteChannel BTResult
       -> WriteChannel W
       -> StateT FilterState (DP st) ()
actor4 (_, l) _ _ query _ rbtr _ _ _ wq _ wbtr _ = do
  state' <- get
  case state' of
    BiTriangles bttt -> do
      rbtr |=> wbtr
      foldM_ query $ \e -> do
        push e wq
        unless (hasNotBT bttt) $ sendBts bttt e wbtr
    _ -> pure ()

sendBts :: MonadIO m => BTTT -> Q -> WriteChannel BTResult -> m ()
sendBts (BTTT bttt) q@(Q c _ _) wbtr = case c of
  ByVertex vx    -> forM_ bttt (\bt -> filterBTByVertex bt vx (flip push wbtr . RBT q))
  ByEdge   edges -> forM_ bttt (\bt -> filterBTByEdge bt edges (flip push wbtr . RBT q))
  AllBT          -> forM_ bttt (R.mapM_ (flip push wbtr . RBT q) . buildBT)
  Count          -> forM_ bttt (flip push wbtr . RC q . R.length . buildBT)
  _              -> pure ()
\end{minted}
\caption{[\mintinline{shell}{BTriangle.hs}] $\ad$}
\label{src:dpbt:5}
\end{listing}

Finally $\ad$ in \autoref{src:dpbt:5} shows the pattern match done over the query $Q$ sum type and the construction
of the final \acrshort{bt} to be downstream to the $\obt$. We are ommiting here the function definition of \mintinline{haskell}{filterBTByEdge}
and \mintinline{haskell}{filterBTByVertex}.

\section{Chapter Summary}
This chapter presents the details of the \acrshort{dpbt} algorithm. In the first part, we have introduced the sketch of the algorithm.
Then, we have described each of the pseudo-code definitions of each component: $\ibt, \gbt, \fbt, \obt$ and actors. 
After that, we have presented a complexity analysis and correctness proof of the pseudo-code algorithm.
At the end of the chapter, we have shown how we implemented this using \acrshort{dpfh} is described in \autoref{dp-hs}.

