\section{Introduction}\label{intro}
Effective streaming processing of large amounts of data has been studied for several years \cite{enumeratingsg, exploting, onthefly} 
as a key factor providing fast and incremental results in big data algorithmic problems. One of the most explored techniques, 
regardless of the approach, is the exploitation of parallel techniques to take advantage of the available computational power as much as possible. 
In that regard, the \acrfull{dp} \cite{dpdef} has lately emerged as one of the models that exploit data streaming processing using a dynamic pipeline parallelism approach \cite{onthefly}. 
This computational model has been designed with a functional focus, where the main components of the paradigm are functional stages or pipes which dynamically enlarge and shrink depending on incoming data.  
The details of the specific requirements of the Haskell system according to the results of the proof of concept will be presented in \autoref{dp-hs}.

One of the biggest challenges of implementing a \acrfull{dpf} is to find a proper set of tools and programming language which can take advantage of both of its primary aspects: \begin{inparaenum}[i\upshape)]
\item  \emph{fast parallel} processing and 
\item  \emph{strong theoretical} foundations that manage computations as first-class citizens.
 \end{inparaenum}
\acrfull{hs} is a statically typed pure functional language that has been designed and evolved from its birth in 1987, 
on strong theoretical foundations where computations are primary entities, and at the same time has been providing a powerful set of tools for writing multithreading and parallel programs with optimal performance \cite{parallelbook, monadpar}.

\textbf{Problem Research and Objective:}\label{research:obj} The main objective of this work is to explore the feasibility of using a  \acrfull{fp} language to implement a \acrshort{dpf}. In particular, we tackle the problem of establishing the basis of an implementation of a \acrshort{dpf}  in \acrshort{hs}, a pure functional language. 
This is,  our aim is to determine the particular features (i.e., versions and libraries) of this language that will allow for an efficient implementation of the \acrshort{dpf}. 
To be concrete, through a particular and very relevant problem as the computation of the \acrfull{wcc} of a graph,  we study the critical features required in \acrshort{hs} for a \acrshort{dpf} implementation.

\textbf{Contributions:} A proof of concept of the implementation of a $\DP$ for \acrshort{wcc} using \acrshort{hs}; the results of the empirical study suggests that   \acrshort{hs} is a suitable language for implementing \acrshort{dp}. This work also contributes to building the first abstraction approximation of a future framework/library of this computational model in that language. 

The rest of this paper is organized as follows. 
Next section  presents  the basic notions used through this work. 
In \autoref{prole}  the proof of concept is analyzed. To be concrete, in this section an algorithm for enumerating \acrshort{wcc} using \acrshort{dp} and its implementation using parallel \acrshort{hs} are introduced. 
In \autoref{sec:evaluation}, the experiments conducted to assess how  Haskell supports the dynamic pipeline implementation for enumerating \acrshort{wcc} are described and their results reported. 
In \autoref{dp-hs} the design of the \acrlong{dpfh} and the most relevant details of its implementation are deeply explained. In particular, all the \acrshort{hs} data types and language techniques used in the implementation are detailed. 
The justification of the used  external libraries for the runtime system are presented at the end of this section. Section \ref{sec:wcc-dpf} the results of the experiments conducted to evaluate the performance of  using the \acrshort{dpf} are presented.
In \ref{section:related-work} we present the related work and, finally, conclusions and further work are presented in  \autoref{conc}. 
Part of the content presented through this work has been published in \cite{prole}. 
