\section{Conclusions and Future Work}\label{conc}
The empirical evaluation of the \acrshort{dpwcc} implementation to compute weakly connected components of a graph, evidence suitability, and robustness to provide a Dynamic Pipeline Framework in \acrshort{hs}. Measuring  using \acrshort{dt} and \acrshort{dk} metrics  provide evidence of the continuous behavior of \acrshort{dpfhwcc} and \acrshort{dpwcc} without adding overhead over the baseline implementation using the Haskell  library \acrshort{blwcc}. Regarding the main aspects where DPP is strong, i.e., pipeline parallelism and time processing, the \acrshort{dpfhwcc} and \acrshort{dpwcc}  performance show that Haskell can deal with the requirements for the \acrshort{wcc} problem without penalizing neither execution time nor memory allocation. In particular, the \acrshort{dpfhwcc} and \acrshort{dpwcc}  implementations outperform \acrshort{blwcc} in those cases where the topology of the graph is more sparse, and the largest \acrshort{wcc}s do not include a large percentage of vertices of the original graph. Moreover, the reported results indicate that implementing Dynamic Pipeline in Haskell Programming Language is feasible. More importantly, these results put in perspective the goodness of the proposed Dynamic Pipeline Framework to implement a wide range of algorithms supported by purely functional programming language.

In the future, we plan to apply DPF to other problems of subgraph enumeration, e.g., bi-triangle or graphlets, essential for efficient network analysis. We also plan to compare different language implementations of $\DP$, taking into consideration the promising results reported in the literature \cite{dpp_triangles} and the experimental outcomes presented in this article.
Moreover, as a result of assessing the DPF potential, we plan to develop a new version according to \cite{parallelbook} to reach a higher parallelization level using sparks (\mintinline{haskell}{Par} \textit{Monad}). We envision that using this new approach will allow the DPF to scale. As a result, the DPF will scale up to practical problems with huge input data streams. 

\iffalse
The  implementation of a Dynamic Pipeline to compute the weakly connected component of a graph in  Haskell and the assessment of its performance gives insight about implementing a Dynamic Pipeline Framework in this pure  functional language is  not  only  suitable  but also robust. Measuring  using \acrshort{dt} metrics in \autoref{sub:sub:sec:e2} reveals the advantageous capability of $\dpwcc$ implementation to deliver incremental results compare with default containers library implementation.  Regarding the main aspects where DPP is strong, i.e. pipeline parallelism and time processing, the $\dpwcc$ performance shows that Haskell can deal with the requirements for the \acrshort{wcc} problem without penalizing neither execution time nor memory allocation. In particular the $\dpwcc$ implementation outperforms  in  those  cases  where  the  topology of  the  graph  is  more  sparse  and  where  the  number  of  vertices  in  the  largest  \acrshort{wcc}  is  not  large (all  the  vertices  are  not  in  one  big \acrshort{wcc}). We think this work has gathered enough evidence to show that the implementation of a Dynamic Pipeline in Haskell Programming Language is feasible. This fact opens a wide range of algorithms to be explored using the Dynamic Pipeline Paradigm, supported by purely functional programming language.  Currently, we are addressing the design and definition of a general and parametric \acrshort{dpf} in Haskell taking advantage of all the abstraction mechanisms that Haskell provides and taking into account knowledge obtained in this work. We envision that such implementation requires only a few lines of code, taking advantage  of  already  built  Haskell libraries  and  techniques.    
\fi

\iffalse
We have seen that \acrlong{dp} implemented in Haskell is not only suitable but also robust. We have also seen that this implementation requires only a few lines of code, taking advantage of already built libraries and techniques as we have described in \autoref{section:prob:dp:haskell}.
We have also been able to verify that the implementation outperforms in those cases where the topology of the graph is more sparse and where the number of vertices in the largest \acrshort{wcc} is not large (all the vertices are not in one big \acrshort{wcc}). This behavior is present despite implementing a non-optimal subgraph algorithm for the specific problem of \acrshort{wcc}.
Moreover, we have measure using \acrshort{dt} metrics in \autoref{sub:sub:sec:e2}, the advantageous capability of \acrshort{dpwcc} implementation to deliver incremental results compare with default \texttt{containers} library implementation.
Finally, we have been able to measure the principal aspects where \acrshort{dp} is strong such as pipeline parallelism and time processing showing that \acrshort{hs} can deal with the requirements for the problem without penalizing neither execution time nor memory allocation.
We think this works has gathered enough evidence to show that the implementation of a \acrshort{dpf} is feasible in \acrlong{hs} opening a wide range of algorithms to be explored using the Dynamic Pipeline Paradigm, supported by a purely functional programming language. 
Another important aspect is that we still need to explore in deep the design and definition of the main \acrshort{dpf} in \acrshort{hs} taking advantage of all the abstraction mechanisms that \acrshort{hs} provides.
\fi


