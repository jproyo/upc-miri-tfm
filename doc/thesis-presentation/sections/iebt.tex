\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG (IEBT)}
  \begin{center}
  \large The algorithm consists in \textbf{2 (two) main phases} 
  \end{center}  
  \vspace{2em}   
  \begin{itemize}
    \setlength\itemsep{2em}
    \item \textbf{First Phase}: A \underline{\color{red}Graph Index} structure is created
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG (IEBT)}
  \begin{center}
  \large The algorithm consists in \textbf{2 (two) main phases} 
  \end{center}     
  \vspace{2em}   
  \begin{itemize}
    \setlength\itemsep{2em}
    \item {\color{light}\textbf{First Phase}: A Graph Index structure is created}
    \item \textbf{Second Phase}: Local \underline{\color{red}Queries} can be submitted to the index
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG (IEBT)}
  \begin{center}
  \large A \textbf{Bipartite Graph} is an undirected graph $G=(V,E)$  such that $V=(U\cup L)$, $U\cap L=\emptyset$ and $E\subseteq U\times L$.
  \end{center}     
  \begin{center}
    \small \emph{w.l.o.g.} $U \subseteq \mathbb{N}, L \subseteq \mathbb{N}$ and $(U, <)$, $(L, <)$ are \emph{strict total orders}
  \end{center}            
  \begin{figure}
    \centering
    \resizebox{0.7\textwidth}{!}{\inputtikz{bipartite}}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG (IEBT)}
  \begin{center}
  Let the triples $\mu=(u_1, u_2, u_3)$ and $\ell=(l_1, l_2,l_3)$ on $U$ and $L$, respectively, i.e.  $\{u_1, u_2, u_3\} \subseteq U$, $\{l_1, l_2,l_3\} \subseteq L$. 
  The 6-cycle $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$  is a \textbf{Bitriangle} in $G$. 
  \end{center}      
  \begin{figure}
    \centering
    \resizebox{0.7\textwidth}{!}{\inputtikz{bitriangle}}
  \end{figure}
\end{frame}

\begin{frame}[fragile]{IEBT: First Phase - Graph Index Structures}
  \begin{center}
    \large We \textbf{introduce} a conceptual framework based on abstract \textbf{compacted structures} to specify the algorithm.
  \end{center}    
  \begin{table}[H]
    \centering
    \resizebox{0.8\textwidth}{!}{
    \begin{tabular}{c c}
     \begin{tabular}{c}\underline{\color{red}Aggregated Wedges}\\$\la l, W_l \ra$\end{tabular} & \begin{tabular}{l}\resizebox{5cm}{2cm}{\inputtikz{bipartite_awg_a}\inputtikz{bipartite_awg_c}}\end{tabular}\\
    \end{tabular}
    }
   \end{table}
\end{frame}

\begin{frame}[fragile]{IEBT: First Phase - Graph Index Structures}
  \begin{center}
    \large We \textbf{introduce} a conceptual framework based on abstract \textbf{compacted structures} to specify the algorithm.
  \end{center}    
  \begin{table}[H]
    \centering
    \resizebox{0.8\textwidth}{!}{
    \begin{tabular}{c c}
     \begin{tabular}{c}\underline{\color{red}Aggregated Wedges}\\$\la l, W_l \ra$\end{tabular} & \begin{tabular}{l}\resizebox{5cm}{2cm}{\inputtikz{bipartite_awg_a}\inputtikz{bipartite_awg_c}}\end{tabular}\\
     \begin{tabular}{c}\underline{\color{red}Aggregated Double Wedges} \\$\la (l_1, l_2), U_l \ra$\end{tabular} & \begin{tabular}{l}\resizebox{4cm}{2cm}{\inputtikz{bipartite_adwg_a}}\end{tabular}\\
    \end{tabular}
    }
   \end{table}
\end{frame}

\begin{frame}[fragile]{IEBT: First Phase - Graph Index Structures}
  \begin{center}
    \large We \textbf{introduce} a conceptual framework based on abstract \textbf{compacted structures} to specify the algorithm.
  \end{center}    
  \begin{table}[H]
    \centering
    \resizebox{0.8\textwidth}{!}{
    \begin{tabular}{c c}
     \begin{tabular}{c}\underline{\color{red}Aggregated Wedges}\\$\la l, W_l \ra$\end{tabular} & \begin{tabular}{l}\resizebox{5cm}{2cm}{\inputtikz{bipartite_awg_a}\inputtikz{bipartite_awg_c}}\end{tabular}\\
     \begin{tabular}{c}\underline{\color{red}Aggregated Double Wedges} \\$\la (l_1, l_2), U_l \ra$\end{tabular} & \begin{tabular}{l}\resizebox{4cm}{2cm}{\inputtikz{bipartite_adwg_a}}\end{tabular}\\
     \begin{tabular}{c}\underline{\color{red}Aggregated Bitriangles} \\$\langle \ell, \hat{U}_l\rangle$\end{tabular} & \begin{tabular}{l}\resizebox{4cm}{2cm}{\inputtikz{bipartite_abt_a}}\end{tabular}\\
    \end{tabular}
    }
   \end{table}
\end{frame}

\begin{frame}[fragile]{IEBT: Second Phase - Queries}
  \begin{center}
    \large We \textbf{define} a \underline{\color{red}Query Operator} for extracting bitriangles from the index which can be:
  \end{center}  
  \vspace{2em}
  \begin{itemize}
    \setlength\itemsep{2em}
    \item \textbf{$\mathcal{P}(U+L)$}: For extracting BT \underline{\color{blue}according to vertices} from $U$ or $L$
  \end{itemize}  
\end{frame}

\begin{frame}[fragile]{IEBT: Second Phase - Queries}
  \begin{center}
    \large We \textbf{define} a \underline{\color{red}Query Operator} for extracting bitriangles from the index which can be:
  \end{center}  
  \vspace{2em}
  \begin{itemize}
    \setlength\itemsep{2em}
    \item \textbf{$\mathcal{P}(U+L)$}: For extracting BT \underline{\color{blue}according to vertices} from $U$ or $L$
    \item \textbf{$\mathcal{P}(E)$}: For extracting BT \underline{\color{blue}according to edges} from $E$
  \end{itemize}  
\end{frame}

% \begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
%   \begin{center}
%     We build first \textbf{Aggregated Wedges}: a pair $\la l, W_l \ra$, where $l \in L$, $W_l \subseteq U$ and for all $u \in W_l$, the edge  $(u,l)\in E$
%   \end{center}    
%   \begin{figure}
%     \centering
%     \resizebox{0.8\textwidth}{!}{\inputtikz{bipartite_awg_a}\inputtikz{bipartite_awg_b}\inputtikz{bipartite_awg_c}}
%   \end{figure}
% \end{frame}

% \begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
%   \begin{center}
%     Then, \textbf{Aggregated Double Wedges}: a pair  $\la (l_1, l_2), U_l \ra$, where $\{l_1,l_2\}\subseteq L$ and  for all $u_i \in I, u_j \in J$ and $u_k \in K$, $\{(u_i, l_1), (u_j, l_1), (u_j, l_2), (u_k, l_2)\} \in E$.
%     $I \subseteq U, J \subseteq U$ and $K \subseteq U$, where $I, J$ and $K$ are disjoint sets. 
%   \end{center}    
%   \begin{figure}
%     \centering
%     \resizebox{0.6\textwidth}{!}{\inputtikz{bipartite_adwg_a}}
%   \end{figure}
% \end{frame}

% \begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
%   \begin{center}
%     \textbf{Finally}, \textbf{Aggregated Bitriangles}: is a pair  $\langle \ell, \hat{U}_l\rangle$, 
%     where $\ell=(l_1, l_2, l_3)$ is a triple on $L$, $l_1 < l_2 < l_3$ and for all $\la I, J, K\ra$ and for all $\mu=(u_i, u_j, u_k)$ such that $u_i \in I, u_j \in J, u_k \in K$, $BT_{\ell}^{\mu} \in \mathsf{BT}$.
%   \end{center}    
%   \begin{figure}
%     \centering
%     \resizebox{0.6\textwidth}{!}{\inputtikz{bipartite_abt_a}}
%   \end{figure}
% \end{frame}


\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{center}
    \textbf{Dynamic Pipeline} Configuration for Enumerating BT in BG
  \end{center}    
  \begin{figure}
    \centering  
    \resizebox{0.7\textwidth}{!}{\inputtikz{btDP}}
  \end{figure}
  \begin{figure}
    \centering  
    \resizebox{0.7\textwidth}{!}{\inputtikz{btDP_actor1}}
  \end{figure}
\end{frame}

% \begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
%   \begin{center}
%     \large Lets see how the Actors' Filter solve this
%   \end{center} 
%   \begin{center}
%   \resizebox{1\textwidth}{!}{  
%   \begin{algorithm}[H]
%     \SetKwInOut{P}{Filter Parameter}
%     \SetKwInOut{FS}{Filter State}
%     \SetKwInOut{IC}{Input Channels}
%     \SetKwInOut{OC}{Output Channels}
%     \SetKwFunction{actora}{actor1}
%     \SetKwFunction{actorb}{actor2}
%     \SetKwFunction{actorc}{actor3}
%     \SetKwFunction{actord}{actor4}
%     \SetKwFunction{filter}{filter}
%     \SetKwProg{df}{def}{:}{end}
%     \SetAlgorithmName{}{fil}{}
%     \SetAlgoRefName{[A4]}
%     \P{$l \in L$}
%     \FS{$\st = \aw + \mathcal{P}(\dw) + \mathcal{P}(\at)$}
%     \IC{$ IC = \la IC_E, IC_{W_l1}, IC_{W_l2}, IC_Q, IC_{BT} \ra $}
%     \OC{$ OC = \la OC_E, OC_{W_l1}, OC_{W_l2}, OC_Q, OC_{BT} \ra $}
%     \df{\filter{}}{
%           $\actora()$\\
%           $\actorb()$\\
%           $\actorc()$\\
%           $\actord()$\\
%     }
%   \end{algorithm}  
%   }  
% \end{center} 
% \end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{center}
    \underline{\textbf{\texttt{actor1}: Aggregated Wedges}}
  \end{center}
  \begin{tikzpicture}[overlay, remember picture]
    \node[xshift=-4cm,yshift=-5cm] at (current page.north east) {
      \resizebox{5cm}{2cm}{\inputtikz{bipartite_awg_a}\inputtikz{bipartite_awg_c}}
    };
  \end{tikzpicture}
  \resizebox{!}{0.3\textheight}{  
    \begin{algorithm}[H]
      \SetKwFunction{acta}{actor1}
      \SetKwProg{df}{def}{:}{end}
      \df{\acta{}}{
      $\la l, W_l \ra \leftarrow \gs$\\
      \ForAll{$(u',l') \in IC_E$}
      {%
      \color{red!80}
      \uIf{$l = l'$}{
        $W_l \leftarrow W_l \cup \{u'\}$
      }\Else{$\p((u',l'),OC_E)$}
      }
      \If{$|W_l| > 1$}{
          \color{red!80}
          $\us(\la l, W_l \ra)$\\ 
          $\p(\la l, W_l \ra, OC_{W_l1})$\\
      }
      }
      \end{algorithm}
  }
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{center}
    \underline{\textbf{\texttt{actor2}: Aggregated Double Wedges}}
  \end{center}
  \begin{tikzpicture}[overlay, remember picture]
    \node[xshift=-4cm,yshift=-5cm] at (current page.north east) {
      \resizebox{5cm}{3cm}{\inputtikz{bipartite_adwg_a}}
    };
  \end{tikzpicture}
  \resizebox{!}{0.4\textheight}{  
    \begin{algorithm}[H]
      \SetKwFunction{actb}{actor2}
      \SetKwProg{df}{def}{:}{end}
      \BlankLine
      \df{\actb{}}{
      $\la l, W_l \ra \leftarrow \gs$\\
      \ForAll{$\la l', W_l' \ra \in IC_{W_l1}$}{
        \color{red!80}
        $\p(\la l', W_l \ra, OC_{W_l1})$\\
        \color{black}
        $\dwi \leftarrow \emptyset$\\
        \If{$W_l' \cap W_l \neq \emptyset$}{ 
              \color{blue!80}
              $(l_l, l_u) \leftarrow (\argmin_{l,l'}, \argmax_{l,l'})$\\
              \uIf{$l < l'$}{
                    $(W_{l_l}, W_{l_u}) \leftarrow (W_l, W_l')$
              }\Else{
                    $(W_{l_l}, W_{l_u}) \leftarrow (W_l', W_l)$
              }
              $I \leftarrow W_{l_l} \setminus W_{l_u}$\\ 
              $J \leftarrow W_{l_l} \cap W_{l_u}$\\
              $K \leftarrow W_{l_u} \setminus W_{l_l}$\\
              $U_l \leftarrow \la I, J, K\ra$\\
              \color{red!80}
              $\dwi \leftarrow dw \cup \{\la (l_l, l_u), U_l \ra\}$
        }
      }
      \color{red!80}$\us(\dwi)$
      }
      \end{algorithm}
  }  
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{center}
    \underline{\textbf{\texttt{actor3}: Aggregated Bitriangles}}
  \end{center}
  \begin{tikzpicture}[overlay, remember picture]
    \node[xshift=-5cm,yshift=-2.8cm] at (current page.north east) {
      \resizebox{1.5cm}{1.5cm}{\inputtikz{awg_b}}
    };
    \node[xshift=-3.8cm,yshift=-2.8cm,draw,fill=white,circle,text centered,minimum height=0.05mm,minimum width=0.05mm] at (current page.north east) {
      \tiny\color{red}\textbf{+}
    };
    \node[xshift=-1.5cm,yshift=-2.8cm] at (current page.north east) {
      \resizebox{3cm}{2cm}{\inputtikz{bipartite_adwg_a}}
    };
    \tikz[baseline] \draw [<-, line width=7pt,>=latex,red] (-9cm,0cm) -- ++(0,50pt);
    \node[xshift=-3cm,yshift=-7cm] at (current page.north east) {
      \resizebox{5cm}{3cm}{\inputtikz{bipartite_abt_a}}
    };
  \end{tikzpicture}
  \resizebox{!}{0.4\textheight}{  
    \begin{algorithm}[H]
      \SetKwFunction{actc}{actor3}
      \SetKwProg{df}{def}{:}{end}
      \BlankLine
      \df{\actc{}}{
        $\dwi \leftarrow \gs$\\
        $\ati \leftarrow \emptyset$\\
        \ForAll{$\la l', W_l \ra \in IC_{W_l2}$}{
          \color{red!80}
          $\p(\la l', W_l \ra, OC_{W_l2})$\\ 
          \ForEach{$\la (l_l, l_u), \la I, J, K \ra \ra \in \dwi, l_l < l' \land l_u > l'$}{
            \color{blue!80}
            $I' \leftarrow I \cup J$\\
            $K' \leftarrow K \cup J$\\
            \If{$W_l \cap I' \neq \emptyset \land W_l \cap K' \neq \emptyset$}{
                  $I' \leftarrow I' \cap W_l$\\
                  $K' \leftarrow K' \cap W_l$\\
                  $\hat{U}_l  \leftarrow \la I', J, K' \ra$\\
                  \color{red!80}
                  $\ati \leftarrow \ati \cup \big\{\la (l_l, l', l_u), \hat{U}_l \ra\big\}$
                  \color{black}
            }
          }
        }      
        \color{red!80}
        $\us(\ati)$\\
      }
    \end{algorithm}
  }  
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{center}
    \underline{\textbf{\texttt{actor4}: Process Query to incrementally enumerate Bitriangles}}
  \end{center}
  \begin{tikzpicture}[overlay, remember picture, show background rectangle]
    \node[xshift=-3cm,yshift=-5.5cm,label=above:{If $\mathcal{P}(U+L) = \{3\}$ then},label=below:{will be enumerated}] at (current page.north east) {
      \resizebox{3cm}{2cm}{\inputtikz{bipartite_bt_a}}
    };
  \end{tikzpicture}
  \resizebox{!}{0.4\textheight}{  
    \begin{algorithm}[H]
      \SetKwFunction{butV}{buildBtVertex}
      \SetKwFunction{butE}{buildBtEdge}      
      \SetKwFunction{actd}{actor4}
      \SetKwProg{df}{def}{:}{end}
      \BlankLine
      \df{\actd{}}{
        $\ati \leftarrow \gs$\\
        \ForAll{$Q \in IC_Q$}{
          \ForEach{$\la (l_l, l_m, l_u), \la I,J,K \ra \ra \in \ati$}{
            \color{blue!80}
            \Switch{$Q$}{
                  \color{red!80}
                  \Case{$\mathcal{P}(U + L)$}{
                    \color{blue!80}
                    \If{$\mathcal{P}(U + L) \cap \{l_l, l_m, l_u\} \neq \emptyset \lor \mathcal{P}(U + L) \cap (I \cup J \cup K) \neq \emptyset$}{
                      \color{red!80}
                      $\btii \leftarrow \butV(\la (l_l, l_m, l_u), \la I,J,K \ra \ra), \mathcal{P}(U + L))$\\
                      \ForAll{$\bti \in \btii$}{
                        $\p(\bti, OC_{BT})$
                      }
                      \color{black}
                    }
                  }
                  \color{blue!80}
                  \Case{$\mathcal{P}(E)$}{
                      \tcp*[h]{SAME FOR EDGES......}\\
                  }
            }
          }
        }
      }
    \end{algorithm}
  }  
\end{frame}


\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{block}{Correctness of the Algorithm}
    We need to prove that the algorithm \textbf{can enumerate all bitriangles} in the graph and also that there are \textbf{no duplicates in the enumeration}.
  \end{block}
\end{frame}


\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{theorem}[Uniqueness] 
    Given a bipartite graph $G = ((U\cup L),E)$, $\forall \btii\in\bt$  \acrshort{iebt} stores $\btii$ in an $\ati\in \at$ only once.
  \end{theorem}
  \vspace{1.5cm}
  \begin{theorem}[All Bitriangles can be enumerated]
    Given a bipartite graph $G$, if the bitriangle $\btii = (u_1,l_1,u_2,l_3,$ $u_3,l_2,u_1)\in \bt$, then $\btii$  can be enumerated.
  \end{theorem}  
\end{frame} 

\iffalse
\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{proof}[Proof. No Bitriangles are duplicated]   
  Let $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$, such that $l_1 < l_2 <l_3$. For every feasible permutation  starting with a node in $U$ we are going to proof that only one will be accepted by $\ab$, or $\ac$.  
  \begin{itemize}
        \item According to lines 7-12 of $\ab$ $(u_1,l_2,u_3,l_3,u_2,l_1,u_1)$ is  not accepted  when constructing elements of $\dw$ to be used by $\ac$  because $l_2 > l_1$ 
        \item According to lines 7 of $\ac$ $(u_3,l_2,u_1,l_1,u_2,l_3,u_3)$ is not accepted because $l_2 > l_1$
        \item According to lines 7-12 of $\ab$ $(u_3,l_3,u_2,l_1,u_1,l_2,u_3)$ is  not accepted  when constructing elements of $\dw$ to be used by $\ac$  because  $l_3 > l_2$
        \item According to lines 7-12 of $\ab$ $(u_2,l_3,u_3,l_2,u_1,l_1,u_2)$ not accepted because $l_3 > l_1 $
  \end{itemize}
  \end{proof}  
\end{frame}

\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{proof}[Proof. (Cont.) No Bitriangles are duplicated]   
  Let $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$, such that $l_1 < l_2 <l_3$. For every feasible permutation  starting with a node in $U$ we are going to proof that only one will be accepted by $\ab$, or $\ac$.  
  \begin{itemize}
        \item According to lines 7-12 of $\ab$ and line 7 in $\ac$ $(u_2,l_1,u_1,l_2,u_3,l_3,u_2)$ is accepted because $l_1 < l_3 $ and $l_1 < l_2 <l_3$ 
        \item According to  line 7 in $\ac$ $(u_1, l_1,u_2,l_3,u_3,l_2,u_1)$ is not accepted because $l_3 > l_2$
  \end{itemize}
  Therefore the  only bitriangle  constructed by the algorithm is the one that satisfies $l_1 < l_2 < l_3$ where $u_1,u_2,u_3$  are distinct and $u_1$ is incident to $l_1$ and $l_2$, $u_2$ is incident to $l_1$ and $l_3$ and $u_3$ is incident to $l_2$ and $u_3$.
  \end{proof}  
\end{frame}


\begin{frame}[fragile]{Algorithm for Incrementally Enumerating BT in BG}
  \begin{proof}[All Bitriangles can be enumerated] 
    \begin{itemize}
      \item Let $\bti =$  $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$, such that $l_1 < l_2 <l_3$ is present in the graph. 
      \item When $\aaa$ acting in filter $F_{l_1}$ ends reading all the edges, $\{u_1,u_2\} \subseteq W_{l_1}$. Also when $\aaa$ in filter $F_{l_3}$ ends reading all the edges, $\{u_2,u_3\} \subseteq W_{l_3}$. 
      \item As $l_1 < l_3$ in $\ab$, in lines 7-12, in filter $F_{l_1}$ or in filter $F_{l_3}$, the pair $(l_1,l_3)$  will be added to $\mathsf{dw}$.
      \item When $\ac$ in lines 7-16, in filter $F_{l_1}$ or in filter $F_{l_3}$ receives $(l_2, W_{l_2})$  will construct the corresponding  $BT$ because of the condition in line 10 is satisfied (non empty intersection). 
    \end{itemize}    
    Therefore, the bitriangle is stored in $\mathsf{bt}$ an thus $(u_1,l_1,u_2,l_3,u_3,l_2,u_1)$ can be listed by $\ad$.
  \end{proof}
  
\end{frame} 
\fi
