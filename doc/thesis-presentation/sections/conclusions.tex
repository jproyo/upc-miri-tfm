\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Conclusions}      
    \begin{itemize}
      \item \textbf{Dynamic Pipeline Paradigm} is a suitable computational model to build an Algorithm for Incrementally Enumerating Bitriangles in large Bipartite Networks. 
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Conclusions}      
    \begin{itemize}
      \item {\color{light}\textbf{Dynamic Pipeline Paradigm} is a suitable computational model to build an Algorithm for Incrementally Enumerating Bitriangles in large Bipartite Networks. }
      \item \textbf{Haskell} has behaved accordingly and efficiently on implementing \textbf{Dynamic Pipeline Paradigm} and solving the Algorithm.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Conclusions}      
    \begin{itemize}
      \item {\color{light}\textbf{Dynamic Pipeline Paradigm} is a suitable computational model to build an Algorithm for Incrementally Enumerating Bitriangles in large Bipartite Networks. }
      \item {\color{light}\textbf{Haskell} has behaved accordingly and efficiently on implementing \textbf{Dynamic Pipeline Paradigm} and solving the Algorithm.}
      \item In the experimental analysis we have \textbf{empirically} shown that the designed \textbf{algorithm is incrementally generating Bitriangles} from large Networks like Dbpedia. 
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Future Work}      
    \begin{itemize}
      \item Solve \textbf{memory consumption} for large graphs.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Future Work}      
    \begin{itemize}
      \item {\color{light}Solve \textbf{memory consumption} for large graphs.}
      \item Selection of \textbf{more efficient Data Structures} to process query commands faster
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Future Work}      
    \begin{itemize}
      \item {\color{light}Solve \textbf{memory consumption} for large graphs.}
      \item {\color{light}Selection of \textbf{more efficient Data Structures} to process query commands faster}
      \item Implement a \textbf{distributed model} for filters, to take advantage of a distributed memory model.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]{Conclusions and Future Work}
  \begin{block}{Future Work}      
    \begin{itemize}
      \item {\color{light}Solve \textbf{memory consumption} for large graphs.}
      \item {\color{light}Selection of \textbf{efficient Data Structures} to process query commands faster}
      \item {\color{light}Implement a \textbf{distributed model} for filters, to take advantage of a distributed memory model.}
      \item \textbf{Improvements on Haskell Framework}: Stream processing and Memory footprint for Boxed Data Types.
    \end{itemize}
  \end{block}
\end{frame}
